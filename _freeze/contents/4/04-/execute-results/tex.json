{
  "hash": "4de033e8a3067cb036b52864215f0fd5",
  "result": {
    "markdown": "# Package: `pandas`\nThe basic data structure for `pandas` is `pandas.DataFrame`. You may treat it as a generalized version of tables.\n\nTo use `pandas`, we just import it. In most cases you would like to use the alias `pd`.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n```\n:::\n\n\nSince `DataFrame` is more like a table, the biggest questions here is not to do computations (which is still very important), but to retrieve, search, sort, merge, etc.. those data. \n\n\n\n\n\n\n\n\n## Basic `pandas`\n\n###  `Series` and `DataFrame`\nA *Series* is a 1-d array-like object which has index. The default index is starting from `0`. You may change the index to be something assigned by you. Thus it can be treated as a generalization of a `dict`.\n\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nobj = pd.Series([3, 1, 2, 4])\nobj\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  0 \\\\\n\\midrule\n0 &  3 \\\\\n1 &  1 \\\\\n2 &  2 \\\\\n3 &  4 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nobj2 = pd.Series([3, 1, 2, 4], index=['a', 'b', 'c', 'd'])\nobj2\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  0 \\\\\n\\midrule\na &  3 \\\\\nb &  1 \\\\\nc &  2 \\\\\nd &  4 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndata3 = {'a': 3, 'b': 1, 'c': 2, 'd': 4}\nobj3 = pd.Series(data3)\nobj3\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  0 \\\\\n\\midrule\na &  3 \\\\\nb &  1 \\\\\nc &  2 \\\\\nd &  4 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nA *DataFrame* represents a rectangular table of data and contains an ordered collection of columns, each of which can be a different value type. The DataFrame has both a row and column index; it can be thought of as a dict of Series all sharing the same index. When displaying a DataFrame, we may use `.head()` to just display the first few rows for efficicy. \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport pandas as pd\n\ndata = {'a': [1, 2, 3, 4, 5, 6, 7],\n        'b': [1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1],\n        'c': ['a', 'b', 'c', 'd', 'e', 'f', 'g']}\ndf = pd.DataFrame(data)\ndf.head()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=tex}\n\\begin{tabular}{lrrl}\n\\toprule\n{} &  a &    b &  c \\\\\n\\midrule\n0 &  1 &  1.1 &  a \\\\\n1 &  2 &  2.1 &  b \\\\\n2 &  3 &  3.1 &  c \\\\\n3 &  4 &  4.1 &  d \\\\\n4 &  5 &  5.1 &  e \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.callout-note}\nWe may use the setting `columns=` or `index=` as well as the methods `.rename(columns=, index=)` to change the column names and the index names. See the following example.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\ndata = pd.DataFrame(np.arange(16).reshape((4, 4)),\n                    index=['Ohio', 'Colorado', 'Utah', 'New York'],\n                    columns=['one', 'two', 'three', 'four'])\n```\n:::\n\n\n:::\n\n### Accessing data\n- A column in a DataFrame can be retrieved as a Series either by dict-like notation or by attribute. What one gets from this is a Series object.\n    - dict-like notation: `df['a']`\n    - by attribute: `df.a`. Note that if the name of the column is not suitable for attribute names, this method doesn't work.\n- Rows are retrieved by `.loc` if using the row index, and by `.iloc` if using the row number.\n\n### Updating data\n- Assign values to a column of a DataFrame will update that column. If the column doesn't exist, new column will be created.\n- When assign values with non-existent row index, that part of the data will be discarded. \n- Any time if there are no values with a specific column and row, it will show as `NaN`. \n\n::: {#exm-}\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport pandas as pd\n\ndata = {'a': [1, 2, 3, 4],\n        'b': [1.1, 2.1, 3.1, 4.1],\n        'c': ['a', 'b', 'c', 'd']}\ndf = pd.DataFrame(data)\n\nnewcol = {1: 'good', 3: 'better', 5: 'best'}\ndf['d'] = pd.Series(newcol)\ndf\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=tex}\n\\begin{tabular}{lrrll}\n\\toprule\n{} &  a &    b &  c &       d \\\\\n\\midrule\n0 &  1 &  1.1 &  a &     NaN \\\\\n1 &  2 &  2.1 &  b &    good \\\\\n2 &  3 &  3.1 &  c &     NaN \\\\\n3 &  4 &  4.1 &  d &  better \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n### Indexing, Selection, and Filtering\n\n- Series indexing `(obj[...])` works analogously to NumPy array indexing, except you\ncan use the Series’s index values instead of only integers. \n\n\n\n\n\n- We can use logical expresssion to filter DataFrame.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport pandas as pd\n\ndata = pd.DataFrame(np.arange(16).reshape((4, 4)),\n                    index=['Ohio', 'Colorado', 'Utah', 'New York'],\n                    columns=['one', 'two', 'three', 'four'])\ndata[data['one']>5]\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=tex}\n\\begin{tabular}{lrrrr}\n\\toprule\n{} &  one &  two &  three &  four \\\\\n\\midrule\nUtah     &    8 &    9 &     10 &    11 \\\\\nNew York &   12 &   13 &     14 &    15 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n- `.loc`, `.iloc`\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nimport pandas as pd\ndata = pd.DataFrame(np.arange(16).reshape((4, 4)),\n                    index=['Ohio', 'Colorado', 'Utah', 'New York'],\n                    columns=['one', 'two', 'three', 'four'])\nprint(data.loc['Colorado', ['two', 'three']])\nprint(data.iloc[2, [3, 0, 1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntwo      5\nthree    6\nName: Colorado, dtype: int32\nfour    11\none      8\ntwo      9\nName: Utah, dtype: int32\n```\n:::\n:::\n\n\n- Slicing with labels behaves differently than normal Python slicing in that the endpoint is inclusive. \n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nimport pandas as pd\n\nobj = pd.Series(np.arange(4.), index=['a', 'b', 'c', 'd'])\nobj['b':'c']\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &    0 \\\\\n\\midrule\nb &  1.0 \\\\\nc &  2.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n- Reindex `.reindex()`:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nimport pandas as pd\ndata = pd.DataFrame(np.arange(16).reshape((4, 4)),\n                    index=['Ohio', 'Colorado', 'Utah', 'New York'],\n                    columns=['one', 'two', 'three', 'four'])\n\ndata.reindex(index = ['Colorado', 'Arkansas', 'New York'],\n             columns = ['three', 'five', 'one'])\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=tex}\n\\begin{tabular}{lrrr}\n\\toprule\n{} &  three &  five &   one \\\\\n\\midrule\nColorado &    6.0 &   NaN &   4.0 \\\\\nArkansas &    NaN &   NaN &   NaN \\\\\nNew York &   14.0 &   NaN &  12.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.callout-note}\n`.loc` and `.reindex` are very similar to each other. The main difference between theses two is that `.loc` will return a view and `.reindex` will return a copy in most cases.\n:::\n\n\n::: {.callout-note}\nWhen locate data using indexes, duplicate labels will return all results.\n:::\n\n\n\n\n### Essential functions\n- Arithmetic and Data Alignment\nElements of the same index and columns will be computed. By default, if any entry is `nan`, the answer will be `nan`. You may use `fill_value` argument to fill the empty slots.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\ndf1 = pd.DataFrame(np.arange(12.).reshape((3, 4)), columns=list('abcd'))\ndf2 = pd.DataFrame(np.arange(20.).reshape((4, 5)), columns=list('abcde'))\ndf2.loc[1, 'b'] = np.nan\n\ndf1.add(df2, fill_value=0)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=tex}\n\\begin{tabular}{lrrrrr}\n\\toprule\n{} &     a &     b &     c &     d &     e \\\\\n\\midrule\n0 &   0.0 &   2.0 &   4.0 &   6.0 &   4.0 \\\\\n1 &   9.0 &   5.0 &  13.0 &  15.0 &   9.0 \\\\\n2 &  18.0 &  20.0 &  22.0 &  24.0 &  14.0 \\\\\n3 &  15.0 &  16.0 &  17.0 &  18.0 &  19.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\nRelatedly, when reindexing a Series or DataFrame, you can also specify a `fill_value`.\n\n### Function Application and Mapping\nWe may apply functions to each row/column of a DataFrame. If the function is built-in function that is compatible with DataFrame, you can directly call the function that it will be applied automatically to each row/column. If it is not, we can call `apply` to get the desired result. \n\n\n::: {#exm-}\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nimport pandas as pd\ndata = pd.DataFrame(np.random.rand(4, 4),\n                    index=['Ohio', 'Colorado', 'Utah', 'New York'],\n                    columns=['one', 'two', 'three', 'four'])\n\nf = lambda x: x.max() - x.min()\n\nprint(data.apply(f))\nprint(data.apply(f, axis='columns'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\none      0.541228\ntwo      0.681330\nthree    0.870863\nfour     0.829540\ndtype: float64\nOhio        0.794118\nColorado    0.787479\nUtah        0.930190\nNew York    0.618147\ndtype: float64\n```\n:::\n:::\n\n\n:::\n\n\nWe can use more complicated function to get more complicated result.\n\n::: {#exm-}\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nimport pandas as pd\ndata = pd.DataFrame(np.random.rand(4, 4),\n                    index=['Ohio', 'Colorado', 'Utah', 'New York'],\n                    columns=['one', 'two', 'three', 'four'])\n\nf = lambda x: pd.Series([x.max(), x.min()], index=['max', 'min'])\n\nprint(data.apply(f))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          one       two     three      four\nmax  0.976593  0.855411  0.759659  0.736943\nmin  0.267597  0.228392  0.288932  0.238394\n```\n:::\n:::\n\n\n:::\n\n\n### Sorting and Ranking\n\n- `.sort_values(by=)`\n- `.rank(ascending=, method=)`\n\n\n\n\n### Summarizing and Computing Descriptive Statistics\n\n- `sum`, `cumsum`\n- `mean`, `median`\n- `.describe()`\n- `.cov`, `.corr`\n\n### Unique Values, Value Counts, and Membership\n- `unique`\n- `value_counts`\n\n\n\n### Reading and Writing Data in Text Format\n- `read_csv`\n- `read_excel`\n- `df.to_csv`\n\n\n### Copies and views\n\n- `inplace`\n\n\n## Data cleaning\n\n### Handling Missing Data\n\n- `np.nan`, `pd.NA`\n- `pd.isnull()`, `np.isnan()`\n- `dropna`, `fillna`\n\n\n::: {#exm-}\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\ndata = pd.DataFrame([[1., 6.5, 3.], [1., np.nan, np.nan], \n                     [np.nan, np.nan, np.nan], [np.nan, 6.5, 3.]])\ncleaned = data.dropna()\ncleanedrow = data.dropna(how='all')\ndata\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=tex}\n\\begin{tabular}{lrrr}\n\\toprule\n{} &    0 &    1 &    2 \\\\\n\\midrule\n0 &  1.0 &  6.5 &  3.0 \\\\\n1 &  1.0 &  NaN &  NaN \\\\\n2 &  NaN &  NaN &  NaN \\\\\n3 &  NaN &  6.5 &  3.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\ncleaned\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=tex}\n\\begin{tabular}{lrrr}\n\\toprule\n{} &    0 &    1 &    2 \\\\\n\\midrule\n0 &  1.0 &  6.5 &  3.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ncleanedrow\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=tex}\n\\begin{tabular}{lrrr}\n\\toprule\n{} &    0 &    1 &    2 \\\\\n\\midrule\n0 &  1.0 &  6.5 &  3.0 \\\\\n1 &  1.0 &  NaN &  NaN \\\\\n3 &  NaN &  6.5 &  3.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndata[4] = np.nan\ncleaned1 = data.dropna(axis=1, how='all')\ncleanedthresh = data.dropna(thresh=2)\ndata\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=tex}\n\\begin{tabular}{lrrrr}\n\\toprule\n{} &    0 &    1 &    2 &   4 \\\\\n\\midrule\n0 &  1.0 &  6.5 &  3.0 & NaN \\\\\n1 &  1.0 &  NaN &  NaN & NaN \\\\\n2 &  NaN &  NaN &  NaN & NaN \\\\\n3 &  NaN &  6.5 &  3.0 & NaN \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ncleaned1\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=tex}\n\\begin{tabular}{lrrr}\n\\toprule\n{} &    0 &    1 &    2 \\\\\n\\midrule\n0 &  1.0 &  6.5 &  3.0 \\\\\n1 &  1.0 &  NaN &  NaN \\\\\n2 &  NaN &  NaN &  NaN \\\\\n3 &  NaN &  6.5 &  3.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\ncleanedthresh\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=tex}\n\\begin{tabular}{lrrrr}\n\\toprule\n{} &    0 &    1 &    2 &   4 \\\\\n\\midrule\n0 &  1.0 &  6.5 &  3.0 & NaN \\\\\n3 &  NaN &  6.5 &  3.0 & NaN \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nfill0 = data.fillna(0)\nfilldict = data.fillna({1: 0.5, 2: -0.1})\ndata\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=tex}\n\\begin{tabular}{lrrrr}\n\\toprule\n{} &    0 &    1 &    2 &   4 \\\\\n\\midrule\n0 &  1.0 &  6.5 &  3.0 & NaN \\\\\n1 &  1.0 &  NaN &  NaN & NaN \\\\\n2 &  NaN &  NaN &  NaN & NaN \\\\\n3 &  NaN &  6.5 &  3.0 & NaN \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nfill0\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=tex}\n\\begin{tabular}{lrrrr}\n\\toprule\n{} &    0 &    1 &    2 &    4 \\\\\n\\midrule\n0 &  1.0 &  6.5 &  3.0 &  0.0 \\\\\n1 &  1.0 &  0.0 &  0.0 &  0.0 \\\\\n2 &  0.0 &  0.0 &  0.0 &  0.0 \\\\\n3 &  0.0 &  6.5 &  3.0 &  0.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nfilldict\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=23}\n```{=tex}\n\\begin{tabular}{lrrrr}\n\\toprule\n{} &    0 &    1 &    2 &   4 \\\\\n\\midrule\n0 &  1.0 &  6.5 &  3.0 & NaN \\\\\n1 &  1.0 &  0.5 & -0.1 & NaN \\\\\n2 &  NaN &  0.5 & -0.1 & NaN \\\\\n3 &  NaN &  6.5 &  3.0 & NaN \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n### Data Transformation\n\n- `.duplicated()`, `drop_duplicates()`\n\n\n::: {#exm-}\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\n\ndata = pd.DataFrame({'k1': ['one', 'two'] * 3 + ['two'], \n                     'k2': [1, 1, 2, 3, 3, 4, 4]})\ndata.drop_duplicates(['k1'], keep='last')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=24}\n```{=tex}\n\\begin{tabular}{llr}\n\\toprule\n{} &   k1 &  k2 \\\\\n\\midrule\n4 &  one &   3 \\\\\n6 &  two &   4 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n- `pd.Series.map()`, `pd.DataFrame.apply()`\n\n\n::: {#exm-}\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\ndata = pd.DataFrame({'food': ['bacon', 'pulled pork', 'bacon',\n                     'Pastrami', 'corned beef', 'Bacon',\n                     'pastrami', 'honey ham', 'nova lox'],\n                     'ounces': [4, 3, 12, 6, 7.5, 8, 3, 5, 6]})\n\nmeat_to_animal = {\n    'bacon': 'pig',\n    'pulled pork': 'pig',\n    'pastrami': 'cow',\n    'corned beef': 'cow',\n    'honey ham': 'pig',\n    'nova lox': 'salmon'\n    }\n\ndata['animal'] = data['food'].str.lower().map(meat_to_animal)\n\ndata['food'].map(lambda x: meat_to_animal[x.lower()])\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &    food \\\\\n\\midrule\n0 &     pig \\\\\n1 &     pig \\\\\n2 &     pig \\\\\n3 &     cow \\\\\n4 &     cow \\\\\n5 &     pig \\\\\n6 &     cow \\\\\n7 &     pig \\\\\n8 &  salmon \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n- `replace`\n- `rename`\n<!-- - `pd.cut(ages, bins)` -->\n- `describe`\n- `permutation`\n- `sample`\n- dummy variables\n\n### Example: Movies\n\nBelow we explore the MovieLens 1M datasets. You may download it from this [link](assests/datasets/movies.dat). \n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nmnames = ['movie_id', 'title', 'genres']\nmovies = pd.read_table('assests/datasets/movies.dat', sep='::',\n                       header=None, names=mnames, engine=\"python\",\n                       encoding='ISO-8859-1')\n\nall_genres = list()\nmovies['genres'].map(lambda x: all_genres.extend(x.split('|')))\n\ngenres = pd.unique(all_genres)\n\ndummies = pd.DataFrame(np.zeros((len(movies), len(genres))), columns=genres)\n\nfor i, gen in enumerate(movies.genres):\n    indices = dummies.columns.get_indexer(gen.split('|'))\n    dummies.iloc[i, indices] = 1\n\nmovies_windic = movies.join(dummies.add_prefix('Genre_'))\n```\n:::\n\n\n### String Manipulation\n\nThe key idea in this section is that, all methods in `pd.Series.str` will be applied to each entry of the Series.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\ns = pd.Series([\"A \", \" B \", \"C\", \"Aaba\", \" Baca \", np.nan, \"CABA\", \"dog\", \"cat\"])\n\ns.str.lower()\ns.str.split('a')\ns.str.len()\ns.str.strip()\ns.str.replace(\"A\", '1')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=27}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &       0 \\\\\n\\midrule\n0 &      1  \\\\\n1 &      B  \\\\\n2 &       C \\\\\n3 &    1aba \\\\\n4 &   Baca  \\\\\n5 &     NaN \\\\\n6 &    C1B1 \\\\\n7 &     dog \\\\\n8 &     cat \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n\n::: {#exm-}\nWe could also use `.str` to play with column names and row indexes.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\ndf = pd.DataFrame(np.random.randn(3, 2),\n                  columns=[\" Column A \", \" Column B \"], index=range(3))\n\ndf.columns = df.columns.str.strip().str.lower().str.replace(' ', '_')\ndf\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=28}\n```{=tex}\n\\begin{tabular}{lrr}\n\\toprule\n{} &  column\\_a &  column\\_b \\\\\n\\midrule\n0 & -0.230530 & -0.517309 \\\\\n1 & -1.360087 &  0.505717 \\\\\n2 & -0.603123 & -0.132133 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n\n### Regular expression\n\n*Regular expressions* provide a flexible way to search or match string patterns in text. A single expression, commonly called a *regex*, is a string formed according to the regular expression language. Python’s built-in `re` module is responsible for applying regular expressions to strings.\n\nFor details of the regular expression language in Python, please read the official documents from [here](https://docs.python.org/3/library/re.html). There are also many great websites for learning regex. [This](https://regex101.com/) is one example.\n\nWe will briefly mentioned a few rules here.\n\n\n- `.`: matches any character except a newline. \n- `\\d`: matches any digit. It is the same as `[0-9]`.\n- `\\w`: matches any alphabatic or numeric character. It is the same as `[a-zA-Z0-9_]`.\n- `\\s`: matches any whitespaces. It is the same as `[\\t\\n\\r\\f\\v]`.\n- `*`: Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. \n- `+`: Causes the resulting RE to match 1 or more repetitions of the preceding RE, as many repetitions as are possible.\n- `?`: Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. \n- `*?`, `+?`, `??`: The `*`, `+`, and `?` qualifiers are all greedy; they match as much text as possible. Adding `?` after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched.\n- `{m}`: Specifies that exactly m copies of the previous RE should be matched.\n- `{m,n}`: Causes the resulting RE to match from `m` to `n` repetitions of the preceding RE, attempting to match as many repetitions as possible. \n- `{m,n}?`: Causes the resulting RE to match from `m` to `n` repetitions of the preceding RE, attempting to match as few repetitions as possible. \n- `[]`: Used to indicate a set of characters.\n- `()`: set groups.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nimport re\ntext = \"foo bar\\t baz \\tqux\"\npattern = '\\s+'\nregex = re.compile(pattern)\nregex.split(text)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n['foo', 'bar', 'baz', 'qux']\n```\n:::\n:::\n\n\n:::\n\n- `.match()`\n- `.search()`\n- `.findall()`\n- `.split()`\n- `.sub()`\n\nWe can use `()` to specify groups, and use `.groups()` to get access to the results.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nimport re\npattern = r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]{2,4})'\nregex = re.compile(pattern, flags=re.IGNORECASE)\nm = regex.match('wesm@bright.net')\nm.groups()\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n('wesm', 'bright', 'net')\n```\n:::\n:::\n\n\n:::\n\nTo use regex to DataFrame and Series, you may directly apply `.match`, `.findall`, `.replace` after `.str`, with the regex pattern as one of the arguments.\n\n`.extract` is a method that is not from `re`. It is used to extract the matched groups and make them as a DataFrame. \n\n::: {#exm-}\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nmnames = ['movie_id', 'title', 'genres']\nmovies = pd.read_table('assests/datasets/movies.dat', sep='::',\n                       header=None, names=mnames, engine=\"python\",\n                       encoding='ISO-8859-1')\n\npattern = r'([a-zA-Z0-9_\\s,.?:;\\']+)\\((\\d{4})\\)'\nmovies = movies.join(movies.title.str.extract(pattern).rename(columns={0: 'movie title', 1: 'year'}))\n```\n:::\n\n\n:::\n\n\n\n## Data Wrangling\n\n### Hierarchical indexing\nPandas support a more complex indexing system, that the index may have multiple levels. See the following example.\n\n\n::: {$exm-}\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\ndata = pd.Series(np.random.randn(9),\n                 index = [['a', 'a', 'a', 'b', 'b', 'c', 'c', 'd', 'd'],\n                          [1, 2, 3, 1, 2, 3, 1, 2, 3]])\ndata\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=32}\n```{=tex}\n\\begin{tabular}{llr}\n\\toprule\n  &   &         0 \\\\\n\\midrule\na & 1 & -0.095456 \\\\\n  & 2 & -0.164067 \\\\\n  & 3 & -1.058203 \\\\\nb & 1 & -1.872156 \\\\\n  & 2 & -1.018562 \\\\\nc & 3 & -0.988325 \\\\\n  & 1 &  0.369676 \\\\\nd & 2 & -0.322150 \\\\\n  & 3 & -0.352262 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nYou may look at the Series using different levels of indexes.\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\ndata['a']\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &         0 \\\\\n\\midrule\n1 & -0.095456 \\\\\n2 & -0.164067 \\\\\n3 & -1.058203 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\ndata.loc[:, 2]\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &         0 \\\\\n\\midrule\na & -0.164067 \\\\\nb & -1.018562 \\\\\nd & -0.322150 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nYou may use groupby to group by levels and do calculations related to levels. More `.groupby()` will be discussed in the next section. \n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ndata.groupby(level=1).sum()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &         0 \\\\\n\\midrule\n1 & -1.597936 \\\\\n2 & -1.504779 \\\\\n3 & -2.398791 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n\n\nFrom the example above, you may notice that the 2-level hierarchical indexing for a Series works very similar to a DataFrame. In fact, you may translate it back and forth between a 2-level indexing Series and a DataFrame.\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\ndf = data.unstack()\ndf\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=36}\n```{=tex}\n\\begin{tabular}{lrrr}\n\\toprule\n{} &         1 &         2 &         3 \\\\\n\\midrule\na & -0.095456 & -0.164067 & -1.058203 \\\\\nb & -1.872156 & -1.018562 &       NaN \\\\\nc &  0.369676 &       NaN & -0.988325 \\\\\nd &       NaN & -0.322150 & -0.352262 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ndf.stack()\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```{=tex}\n\\begin{tabular}{llr}\n\\toprule\n  &   &         0 \\\\\n\\midrule\na & 1 & -0.095456 \\\\\n  & 2 & -0.164067 \\\\\n  & 3 & -1.058203 \\\\\nb & 1 & -1.872156 \\\\\n  & 2 & -1.018562 \\\\\nc & 1 &  0.369676 \\\\\n  & 3 & -0.988325 \\\\\nd & 2 & -0.322150 \\\\\n  & 3 & -0.352262 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nFor DataFrame the index for both axes can be multiindex. The usual indexing way can be used if you want to start from the first level of the index. The more specific method to extract data is `.xs`.\n\n\n\n::: {#exm-}\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nimport pandas as pd\n\ndf1 = pd.DataFrame(\n    {\n        \"A\": [\"A0\", \"A1\", \"A2\", \"A3\"],\n        \"B\": [\"B0\", \"B1\", \"B2\", \"B3\"],\n        \"C\": [\"C0\", \"C1\", \"C2\", \"C3\"],\n        \"D\": [\"D0\", \"D1\", \"D2\", \"D3\"],\n    },\n    index=[0, 1, 2, 3],\n)\n\ndf2 = pd.DataFrame(\n    {\n        \"A\": [\"A4\", \"A5\", \"A6\", \"A7\"],\n        \"B\": [\"B4\", \"B5\", \"B6\", \"B7\"],\n        \"C\": [\"C4\", \"C5\", \"C6\", \"C7\"],\n        \"D\": [\"D4\", \"D5\", \"D6\", \"D7\"],\n    },\n    index=[4, 5, 6, 7],\n)\n\ndf = pd.concat([df1, df2], keys=['x', 'y'])\n```\n:::\n\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\ndf\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=39}\n```{=tex}\n\\begin{tabular}{llllll}\n\\toprule\n  &   &   A &   B &   C &   D \\\\\n\\midrule\nx & 0 &  A0 &  B0 &  C0 &  D0 \\\\\n  & 1 &  A1 &  B1 &  C1 &  D1 \\\\\n  & 2 &  A2 &  B2 &  C2 &  D2 \\\\\n  & 3 &  A3 &  B3 &  C3 &  D3 \\\\\ny & 4 &  A4 &  B4 &  C4 &  D4 \\\\\n  & 5 &  A5 &  B5 &  C5 &  D5 \\\\\n  & 6 &  A6 &  B6 &  C6 &  D6 \\\\\n  & 7 &  A7 &  B7 &  C7 &  D7 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\ndf['A']\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```{=tex}\n\\begin{tabular}{lll}\n\\toprule\n  &   &   A \\\\\n\\midrule\nx & 0 &  A0 \\\\\n  & 1 &  A1 \\\\\n  & 2 &  A2 \\\\\n  & 3 &  A3 \\\\\ny & 4 &  A4 \\\\\n  & 5 &  A5 \\\\\n  & 6 &  A6 \\\\\n  & 7 &  A7 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\ndf.loc['x']\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=41}\n```{=tex}\n\\begin{tabular}{lllll}\n\\toprule\n{} &   A &   B &   C &   D \\\\\n\\midrule\n0 &  A0 &  B0 &  C0 &  D0 \\\\\n1 &  A1 &  B1 &  C1 &  D1 \\\\\n2 &  A2 &  B2 &  C2 &  D2 \\\\\n3 &  A3 &  B3 &  C3 &  D3 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\ndf.loc['x',3]\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &   x \\\\\n{} &   3 \\\\\n\\midrule\nA &  A3 \\\\\nB &  B3 \\\\\nC &  C3 \\\\\nD &  D3 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\ndf.xs(3, level=1, drop_level=False)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=43}\n```{=tex}\n\\begin{tabular}{llllll}\n\\toprule\n  &   &   A &   B &   C &   D \\\\\n\\midrule\nx & 3 &  A3 &  B3 &  C3 &  D3 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n\n### Combining and Merging Datasets\n\n#### `merge()`\nMerge combines datasets by linking rows using one or more keys. This is from relational databases (e.g., SQL-based). \n\nHere are some examples. \n\n::: {#exm-}\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\nimport pandas as pd\ndf1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],\n                    'data1': range(7)})\ndf2 = pd.DataFrame({'key': ['a', 'b', 'd'], 'data2': range(3)})\n```\n:::\n\n\nThe two DataFrames are displayed as follows.\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\ndf1\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=45}\n```{=tex}\n\\begin{tabular}{llr}\n\\toprule\n{} & key &  data1 \\\\\n\\midrule\n0 &   b &      0 \\\\\n1 &   b &      1 \\\\\n2 &   a &      2 \\\\\n3 &   c &      3 \\\\\n4 &   a &      4 \\\\\n5 &   a &      5 \\\\\n6 &   b &      6 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\ndf2\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=46}\n```{=tex}\n\\begin{tabular}{llr}\n\\toprule\n{} & key &  data2 \\\\\n\\midrule\n0 &   a &      0 \\\\\n1 &   b &      1 \\\\\n2 &   d &      2 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\npd.merge(df1, df2, on='key')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=47}\n```{=tex}\n\\begin{tabular}{llrr}\n\\toprule\n{} & key &  data1 &  data2 \\\\\n\\midrule\n0 &   b &      0 &      1 \\\\\n1 &   b &      1 &      1 \\\\\n2 &   b &      6 &      1 \\\\\n3 &   a &      2 &      0 \\\\\n4 &   a &      4 &      0 \\\\\n5 &   a &      5 &      0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nIf the column names are different in each object, you can specify them separately.\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\ndf3 = pd.DataFrame({'lkey': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],\n                    'data1': range(7)})\ndf4 = pd.DataFrame({'rkey': ['a', 'b', 'd'],\n                    'data2': range(3)})\npd.merge(df3, df4, left_on='lkey', right_on='rkey')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=48}\n```{=tex}\n\\begin{tabular}{llrlr}\n\\toprule\n{} & lkey &  data1 & rkey &  data2 \\\\\n\\midrule\n0 &    b &      0 &    b &      1 \\\\\n1 &    b &      1 &    b &      1 \\\\\n2 &    b &      6 &    b &      1 \\\\\n3 &    a &      2 &    a &      0 \\\\\n4 &    a &      4 &    a &      0 \\\\\n5 &    a &      5 &    a &      0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\nBy default `merge` does an inner join, that the keys in the result are the interesection found in both tables. Below are different types of `merge`. To specify the method for merge, the option is `how`.\n\n- `inner`\n- `left`\n- `right`\n- `outer`\n\nLet's see the following examples.\n\n\n\n\n::: {.grid}\n\n::: {.g-col-6}\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\ndf1 = pd.DataFrame({'Key': [1, 2], 'A': [0, 2], 'B': [1, 3]})\ndf1\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=49}\n```{=tex}\n\\begin{tabular}{lrrr}\n\\toprule\n{} &  Key &  A &  B \\\\\n\\midrule\n0 &    1 &  0 &  1 \\\\\n1 &    2 &  2 &  3 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n::: {.g-col-6}\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\ndf2 = pd.DataFrame({'Key': [1, 3], 'C': [0, 2], 'D': [1, 3]})\ndf2\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=50}\n```{=tex}\n\\begin{tabular}{lrrr}\n\\toprule\n{} &  Key &  C &  D \\\\\n\\midrule\n0 &    1 &  0 &  1 \\\\\n1 &    3 &  2 &  3 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n:::\n\n\n\n::: {.grid}\n\n\n::: {.g-col-6}\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\npd.merge(df1, df2, on='Key', how='inner')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=51}\n```{=tex}\n\\begin{tabular}{lrrrrr}\n\\toprule\n{} &  Key &  A &  B &  C &  D \\\\\n\\midrule\n0 &    1 &  0 &  1 &  0 &  1 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n::: {.g-col-6}\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\npd.merge(df1, df2, on='Key', how='outer')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=52}\n```{=tex}\n\\begin{tabular}{lrrrrr}\n\\toprule\n{} &  Key &    A &    B &    C &    D \\\\\n\\midrule\n0 &    1 &  0.0 &  1.0 &  0.0 &  1.0 \\\\\n1 &    2 &  2.0 &  3.0 &  NaN &  NaN \\\\\n2 &    3 &  NaN &  NaN &  2.0 &  3.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n:::\n\n\n\n::: {.grid}\n\n\n::: {.g-col-6}\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\npd.merge(df1, df2, on='Key', how='left')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=53}\n```{=tex}\n\\begin{tabular}{lrrrrr}\n\\toprule\n{} &  Key &  A &  B &    C &    D \\\\\n\\midrule\n0 &    1 &  0 &  1 &  0.0 &  1.0 \\\\\n1 &    2 &  2 &  3 &  NaN &  NaN \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n::: {.g-col-6}\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\npd.merge(df1, df2, on='Key', how='right')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=54}\n```{=tex}\n\\begin{tabular}{lrrrrr}\n\\toprule\n{} &  Key &    A &    B &  C &  D \\\\\n\\midrule\n0 &    1 &  0.0 &  1.0 &  0 &  1 \\\\\n1 &    3 &  NaN &  NaN &  2 &  3 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n:::\n\n\n\n::: {.callout-note}\nIf a key combination appears more than once in both tables, the resulting table will have the Cartesian product of the associated data. Here is a very basic example with one unique key combination.\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\ndf1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'b'],\n                    'data1': range(6)})\ndf2 = pd.DataFrame({'key': ['a', 'b', 'a', 'b', 'd'],\n                    'data2': range(5)})\npd.merge(df1, df2, on='key', how='left')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=55}\n```{=tex}\n\\begin{tabular}{llrr}\n\\toprule\n{} & key &  data1 &  data2 \\\\\n\\midrule\n0  &   b &      0 &    1.0 \\\\\n1  &   b &      0 &    3.0 \\\\\n2  &   b &      1 &    1.0 \\\\\n3  &   b &      1 &    3.0 \\\\\n4  &   a &      2 &    0.0 \\\\\n5  &   a &      2 &    2.0 \\\\\n6  &   c &      3 &    NaN \\\\\n7  &   a &      4 &    0.0 \\\\\n8  &   a &      4 &    2.0 \\\\\n9  &   b &      5 &    1.0 \\\\\n10 &   b &      5 &    3.0 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note} \nIf the merge keys in a DataFrame is in its index instead of column(s), we could pass `left_index=True` or `right_index=True` or both instead of setting `left_on`/`right_on`/`on`.\n:::\n\n\n::: {#exm-crossexample-deck}\nIf we want to really create a Cartesian product, we may use the option `how='cross'`. For example, we would like to generate a deck of cards, we may use the following codes.\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\nsuit = pd.DataFrame({'suit': ['spades', 'hearts', 'clubs', 'diamonds']})\nface = pd.DataFrame({'face': list(range(1, 14))})\ndeck = pd.merge(suit, face, how='cross')\n```\n:::\n\n\n:::\n\n\n\n#### `concat()`\nThe `concat()` function (in the main pandas namespace) performs concatenation operations along an axis while performing optional set logic (union or intersection) of the indexes (if any) on the other axes.  \n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\nimport pandas as pd\n\ndf1 = pd.DataFrame(\n    {\n        \"A\": [\"A0\", \"A1\", \"A2\", \"A3\"],\n        \"B\": [\"B0\", \"B1\", \"B2\", \"B3\"],\n        \"C\": [\"C0\", \"C1\", \"C2\", \"C3\"],\n        \"D\": [\"D0\", \"D1\", \"D2\", \"D3\"],\n    },\n    index=[0, 1, 2, 3],\n)\n\ndf2 = pd.DataFrame(\n    {\n        \"A\": [\"A4\", \"A5\", \"A6\", \"A7\"],\n        \"B\": [\"B4\", \"B5\", \"B6\", \"B7\"],\n        \"C\": [\"C4\", \"C5\", \"C6\", \"C7\"],\n        \"D\": [\"D4\", \"D5\", \"D6\", \"D7\"],\n    },\n    index=[4, 5, 6, 7],\n)\n\ndf3 = pd.DataFrame(\n    {\n        \"A\": [\"A8\", \"A9\", \"A10\", \"A11\"],\n        \"B\": [\"B8\", \"B9\", \"B10\", \"B11\"],\n        \"C\": [\"C8\", \"C9\", \"C10\", \"C11\"],\n        \"D\": [\"D8\", \"D9\", \"D10\", \"D11\"],\n    },\n    index=[8, 9, 10, 11],\n)\n\npd.concat([df1, df2, df3], keys=['x', 'y', 'z'])\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=57}\n```{=tex}\n\\begin{tabular}{llllll}\n\\toprule\n  &    &    A &    B &    C &    D \\\\\n\\midrule\nx & 0  &   A0 &   B0 &   C0 &   D0 \\\\\n  & 1  &   A1 &   B1 &   C1 &   D1 \\\\\n  & 2  &   A2 &   B2 &   C2 &   D2 \\\\\n  & 3  &   A3 &   B3 &   C3 &   D3 \\\\\ny & 4  &   A4 &   B4 &   C4 &   D4 \\\\\n  & 5  &   A5 &   B5 &   C5 &   D5 \\\\\n  & 6  &   A6 &   B6 &   C6 &   D6 \\\\\n  & 7  &   A7 &   B7 &   C7 &   D7 \\\\\nz & 8  &   A8 &   B8 &   C8 &   D8 \\\\\n  & 9  &   A9 &   B9 &   C9 &   D9 \\\\\n  & 10 &  A10 &  B10 &  C10 &  D10 \\\\\n  & 11 &  A11 &  B11 &  C11 &  D11 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nThe default way of `pd.concat()` is vertically. Note that it will check the column names. If the column names don't match, new columns will be created and `nan` values will be assigned. \n\nIf you want to concatenate the DataFrame horizontally you need to add `axis=1` option.\nSimilarly, row index will be checked before concatenating. See the following example.\n\n::: {#exm-}\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\npd.concat([df1, df2, df3], axis=1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=58}\n```{=tex}\n\\begin{tabular}{lllllllllllll}\n\\toprule\n{} &    A &    B &    C &    D &    A &    B &    C &    D &    A &    B &    C &    D \\\\\n\\midrule\n0  &   A0 &   B0 &   C0 &   D0 &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN \\\\\n1  &   A1 &   B1 &   C1 &   D1 &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN \\\\\n2  &   A2 &   B2 &   C2 &   D2 &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN \\\\\n3  &   A3 &   B3 &   C3 &   D3 &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN \\\\\n4  &  NaN &  NaN &  NaN &  NaN &   A4 &   B4 &   C4 &   D4 &  NaN &  NaN &  NaN &  NaN \\\\\n5  &  NaN &  NaN &  NaN &  NaN &   A5 &   B5 &   C5 &   D5 &  NaN &  NaN &  NaN &  NaN \\\\\n6  &  NaN &  NaN &  NaN &  NaN &   A6 &   B6 &   C6 &   D6 &  NaN &  NaN &  NaN &  NaN \\\\\n7  &  NaN &  NaN &  NaN &  NaN &   A7 &   B7 &   C7 &   D7 &  NaN &  NaN &  NaN &  NaN \\\\\n8  &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &   A8 &   B8 &   C8 &   D8 \\\\\n9  &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &   A9 &   B9 &   C9 &   D9 \\\\\n10 &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  A10 &  B10 &  C10 &  D10 \\\\\n11 &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  NaN &  A11 &  B11 &  C11 &  D11 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n\n::: {#exm-}\nConsider the deck example from @exm-crossexample-deck. This time we would like to use `pd.concat()` to get the result.\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\nsuitlist = ['spades', 'hearts', 'clubs', 'diamonds']\nfacelist = list(range(1, 14))\ndecklist = [pd.DataFrame({'suit': suit, 'face': facelist}) for suit in suitlist]\ndeck = pd.concat(decklist, ignore_index=True)\n```\n:::\n\n\n:::\n\n\n## Data Aggregation and Group Operations\n\n### split-apply-combine model\n\nWe would like to apply group operations based on the split-apply-combine model. \n\n- In the first stage of the process, data contained in a pandas object is *split* into groups based on one or more keys that you provide. We then use `.groupby(keys)` to perform the split step. The result is a grouped `groupby` object.\n- Once this is done, a function is *applied* to each group, producing a new value. \n- Finally the results of all those function applications are combined into a result object. We may apply groupby functions directly as methods to groupby objects.The result is the combined result object.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\nimport pandas as pd\ndf = pd.DataFrame({'key1' : ['a', 'a', 'b', 'b', 'a'],\n                   'key2' : ['one', 'two', 'one', 'two', 'one'],\n                   'data1' : np.random.randn(5),\n                   'data2' : np.random.randn(5)})\ndf\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=60}\n```{=tex}\n\\begin{tabular}{lllrr}\n\\toprule\n{} & key1 & key2 &     data1 &     data2 \\\\\n\\midrule\n0 &    a &  one & -0.749345 & -0.434421 \\\\\n1 &    a &  two & -0.016799 &  1.262916 \\\\\n2 &    b &  one &  0.727810 & -0.116099 \\\\\n3 &    b &  two &  0.287516 &  0.823151 \\\\\n4 &    a &  one &  1.048343 & -0.730971 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nNow we want to group `data1` in `df` by `key1`.\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\ngrouped = df['data1'].groupby(df['key1'])\ngrouped\n```\n\n::: {.cell-output .cell-output-display execution_count=61}\n```\n<pandas.core.groupby.generic.SeriesGroupBy object at 0x000001F9695E5570>\n```\n:::\n:::\n\n\nWhat we get is a groupby object and we could apply group functions to it.\n\nThe method to look at each group is `.get_group`.\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\ngrouped.get_group('a')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=62}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &     data1 \\\\\n\\midrule\n0 & -0.749345 \\\\\n1 & -0.016799 \\\\\n4 &  1.048343 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nWe may directly apply some group functions to the groupby object.\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\ngrouped.mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=63}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &     data1 \\\\\nkey1 &           \\\\\n\\midrule\na    &  0.094066 \\\\\nb    &  0.507663 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\ngrouped.size()\n```\n\n::: {.cell-output .cell-output-display execution_count=64}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &  data1 \\\\\nkey1 &        \\\\\n\\midrule\na    &      3 \\\\\nb    &      2 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nWe could iterate over groups.\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\nfor name, group in grouped:\n    print('name', name)\n    print('group', group)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname a\ngroup 0   -0.749345\n1   -0.016799\n4    1.048343\nName: data1, dtype: float64\nname b\ngroup 2    0.727810\n3    0.287516\nName: data1, dtype: float64\n```\n:::\n:::\n\n\nWe could convert the group object into list and dictionary.\n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\nlist(grouped)\n```\n\n::: {.cell-output .cell-output-display execution_count=66}\n```\n[('a',\n  0   -0.749345\n  1   -0.016799\n  4    1.048343\n  Name: data1, dtype: float64),\n ('b',\n  2    0.727810\n  3    0.287516\n  Name: data1, dtype: float64)]\n```\n:::\n:::\n\n\n::: {.cell execution_count=69}\n``` {.python .cell-code}\ndict(list(grouped))\n```\n\n::: {.cell-output .cell-output-display execution_count=67}\n```\n{'a': 0   -0.749345\n 1   -0.016799\n 4    1.048343\n Name: data1, dtype: float64,\n 'b': 2    0.727810\n 3    0.287516\n Name: data1, dtype: float64}\n```\n:::\n:::\n\n\n:::\n\n### More aggregation functions\n\n- `.describe()`\n- `.count()`\n- `.sum()`\n- `.mean()`\n- `.median`\n- `.std()`, `.var()`\n- `.min()`, `.max()`\n- `.prod()`\n- `first()`, `.last()`\n- `.agg()`\n\n\n### Some examples\n\n\n::: {#exm-}\nConsider the following DataFrame.\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\nimport pandas as pd\ndf = pd.DataFrame({'location': ['East', 'East', 'East', 'East',\n                                'West', 'West', 'West', 'West'],\n                   'data': np.random.randn(8)},\n                   index=['Ohio', 'New York', 'Vermont', 'Florida',\n                          'Oregon', 'Nevada', 'California', 'Idaho'])\ndf.loc[['Vermont', 'Nevada', 'Idaho'], 'data'] = np.nan\n```\n:::\n\n\nWe would like to fill in NA values with the mean from each group.\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\ndf.groupby('location').apply(lambda x: x.fillna(x.mean()))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Local\\Temp\\ipykernel_11584\\2040193686.py:1: FutureWarning: The default value of numeric_only in DataFrame.mean is deprecated. In a future version, it will default to False. In addition, specifying 'numeric_only=None' is deprecated. Select only valid columns or specify the value of numeric_only to silence this warning.\n  df.groupby('location').apply(lambda x: x.fillna(x.mean()))\nC:\\Users\\Xinli\\AppData\\Local\\Temp\\ipykernel_11584\\2040193686.py:1: FutureWarning: Not prepending group keys to the result index of transform-like apply. In the future, the group keys will be included in the index, regardless of whether the applied function returns a like-indexed object.\nTo preserve the previous behavior, use\n\n\t>>> .groupby(..., group_keys=False)\n\nTo adopt the future behavior and silence this warning, use \n\n\t>>> .groupby(..., group_keys=True)\n  df.groupby('location').apply(lambda x: x.fillna(x.mean()))\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=69}\n```{=tex}\n\\begin{tabular}{llr}\n\\toprule\n{} & location &      data \\\\\n\\midrule\nOhio       &     East & -1.548132 \\\\\nNew York   &     East & -0.734146 \\\\\nVermont    &     East & -0.832626 \\\\\nFlorida    &     East & -0.215599 \\\\\nOregon     &     West & -0.832531 \\\\\nNevada     &     West & -0.426181 \\\\\nCalifornia &     West & -0.019831 \\\\\nIdaho      &     West & -0.426181 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nWe could also fill in NA values with predefined values, similar to the non-groupby case.\n\n::: {.cell execution_count=72}\n``` {.python .cell-code}\ndf.groupby('location').apply(lambda x: x.fillna({'East': 0.1,\n                                                 'West': -0.5}[x.name]))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Local\\Temp\\ipykernel_11584\\1912363449.py:1: FutureWarning: Not prepending group keys to the result index of transform-like apply. In the future, the group keys will be included in the index, regardless of whether the applied function returns a like-indexed object.\nTo preserve the previous behavior, use\n\n\t>>> .groupby(..., group_keys=False)\n\nTo adopt the future behavior and silence this warning, use \n\n\t>>> .groupby(..., group_keys=True)\n  df.groupby('location').apply(lambda x: x.fillna({'East': 0.1,\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=70}\n```{=tex}\n\\begin{tabular}{llr}\n\\toprule\n{} & location &      data \\\\\n\\midrule\nOhio       &     East & -1.548132 \\\\\nNew York   &     East & -0.734146 \\\\\nVermont    &     East &  0.100000 \\\\\nFlorida    &     East & -0.215599 \\\\\nOregon     &     West & -0.832531 \\\\\nNevada     &     West & -0.500000 \\\\\nCalifornia &     West & -0.019831 \\\\\nIdaho      &     West & -0.500000 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n## Exercises\nMost problems are based on @Pra2018a.\n\n::: {#exr-}\nPlease use the following code to generate a series `ser`, and then finish the following tasks.\n\n::: {.cell execution_count=73}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\n\nmylist = list('abcedfghijklmnopqrstuvwxyz')\nmyarr = np.arange(26)\nmydict = dict(zip(mylist, myarr))\nser = pd.Series(mydict)\n```\n:::\n\n\n1. Convert the series `ser` into a dataframe `df` with its index as another column on the dataframe.\n2. Pick the two columns of `df` and set them into two serieses `ser1` and `ser2`. \n3. Combine two series `ser1` and `ser2` to form a new dataframe `newdf`, and name their columns `ser1` and `ser2`.\n:::\n\n\n\n\n::: {#exr-}\nConsider two serieses `ser1` and `ser2`. You may use the following `ser1` and `ser2` as an example. The output of each questions below should be a series. You may want to learn the following commands:\n\n- [`np.union1d()`](https://numpy.org/doc/stable/reference/generated/numpy.union1d.html)\n- [`np.intersect1d()`](https://numpy.org/doc/stable/reference/generated/numpy.intersect1d.html)\n- [`np.isin()`](https://numpy.org/doc/stable/reference/generated/numpy.isin.html)\n\n::: {.cell execution_count=74}\n``` {.python .cell-code}\nimport pandas as pd\n\nser1 = pd.Series([1, 2, 3, 4, 5])\nser2 = pd.Series([4, 5, 6, 7, 8])\n```\n:::\n\n\n1. Find all the elements from `ser1` that are also in `ser2`.\n2. Find all the elements from `ser2` that are also in `ser1`.\n3. From `ser1` remove items present in `ser2`.\n4. Find the union of `ser1` and `ser2`.\n5. Find the intersection of `ser1` and `ser2`.\n6. Find all the elemetns that are in either `ser1` or `ser2`, but not both.\n:::\n\n\n\n::: {#exr-}\n## Some statistics\nPlease check the following commands and answer the following questions.\n\n- [`np.percentile()`](https://numpy.org/doc/stable/reference/generated/numpy.percentile.html)\n\nHow to get the minimum, 25th percentile, median, 75th, and max of a numeric series? You may use the following Series as an example.\n\n::: {.cell execution_count=75}\n``` {.python .cell-code}\nimport pandas as pd\nser = pd.Series(np.random.normal(10, 5, 25))\n```\n:::\n\n\n:::\n\n\n\n::: {#exr-}\nPlease use `pd.Series.value_counts()` to calculte the frequency counts of each unique value of the following Series.\n\n::: {.cell execution_count=76}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nser = pd.Series(np.take(list('abcdefgh'), np.random.randint(8, size=30)))\n```\n:::\n\n\n:::\n\n\n::: {#exr-}\nPlease keep the top 2 most frequent items of `ser` as it is and replace everything else as `Other`.\n\n::: {.cell execution_count=77}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nser = pd.Series(np.take(list('abcdefgh'), np.random.randint(8, size=30)))\n```\n:::\n\n\n:::\n\n\n::: {#exr-}\nPlease use `pd.cut` or `pd.qcut` to bin the Series `ser` into 10 equal deciles. You may use the following `ser` as an example.\n\n::: {.cell execution_count=78}\n``` {.python .cell-code}\nimport pandas as pd\nser = pd.Series(np.random.random(20))\n```\n:::\n\n\n:::\n\n\n::: {#exr-}\nConsider the Series `ser`:\n\n::: {.cell execution_count=79}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nser = pd.Series(np.random.randint(1, 10, 7))\n```\n:::\n\n\nFind the positions of numbers that are multiples of 3 from ser.\n:::\n\n\n\n\n\n\n::: {#exr-}\nCompute the mean of `weights` of each `fruit`.\n\n::: {.cell execution_count=80}\n``` {.python .cell-code}\nimport pandas as pd\nfruit = pd.Series(np.random.choice(['apple', 'banana', 'carrot'], 10))\nweights = pd.Series(np.linspace(1, 10, 10))\ndf = pd.DataFrame({'fruit': fruit, 'weights': weights})\n```\n:::\n\n\n:::\n\n\n::: {#exr-}\nConsider the following DataFrame. \n\n::: {.cell execution_count=81}\n``` {.python .cell-code}\nimport pandas as pd\ndf = pd.read_csv('https://raw.githubusercontent.com/selva86/datasets/master/Cars93_miss.csv')\n```\n:::\n\n\n1. Check if `df` has any missing values.\n2. Please count the number of missing values in each column.\n3. Please replace all missing values in `Min.Price` and `Max.Price` with their mean respectively.\n\n<!-- 3. In the original DataFrame, please replace the missing values in `Min.Price` with the column's mean and those in `Max.Price` with the column's median. -->\n:::\n\n\n\n\n\n::: {#exr-}\nReplace the spaces in `my_str = 'dbc deb abed gade'` with the least frequent character.\n:::\n\n\n::: {#exr-}\nSuppress scientific notations like `e-03` in `df` and print up to 4 numbers after decimal.\n\n::: {.cell execution_count=82}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\ndf = pd.DataFrame(np.random.random(4)**10, columns=['random'])\ndf\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=80}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &        random \\\\\n\\midrule\n0 &  6.080198e-07 \\\\\n1 &  4.920480e-01 \\\\\n2 &  1.468951e-06 \\\\\n3 &  1.658286e-01 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n::: {#exr-}\nFormat the values in column `random` of `df` as percentages.\n\n::: {.cell execution_count=83}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\ndf = pd.DataFrame(np.random.random(4), columns=['random'])\ndf\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=81}\n```{=tex}\n\\begin{tabular}{lr}\n\\toprule\n{} &    random \\\\\n\\midrule\n0 &  0.477490 \\\\\n1 &  0.447562 \\\\\n2 &  0.910116 \\\\\n3 &  0.377496 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\n:::\n\n\n\n::: {#exr-}\n## Regular expressions\nPlease use regular expressions to finish the following tasks.\n\n1. Match a string that has an `a` followed by zero or more `b`'s.\n2. Match a string that has an `a` followed by one or more `b`'s.\n3. Match a string that has an `a` followed by zero or one `b`.\n4. Match a string that has an `a` followed by three `b`'s.\n:::\n\n\n\n::: {#exr-}\n## More regex\nFind all words starting with `a` or `e` in a given string:\n\n::: {.cell execution_count=84}\n``` {.python .cell-code}\ntext = \"The following example creates an ArrayList with a capacity of 50 elements. Four elements are then added to the ArrayList and the ArrayList is trimmed accordingly.\"\n```\n:::\n\n\n:::\n\n\n::: {#exr-}\n## More regex\nWrite a Python code to extract year, month and date from a `url1`: \n\n::: {.cell execution_count=85}\n``` {.python .cell-code}\nurl1= \"https://www.washingtonpost.com/news/football-insider/wp/2016/09/02/odell-beckhams-fame-rests-on-one-stupid-little-ball-josh-norman-tells-author/\"\n```\n:::\n\n\n:::\n\n\n\n\n::: {#exr-}\n## More regex\nPlease use regex to parse the following str to create a dictionary.\n\n::: {.cell execution_count=86}\n``` {.python .cell-code}\ntext = r'''\n{\n    name: Firstname Lastname;\n    age: 100;\n    salary: 10000 \n}\n'''\n```\n:::\n\n\n:::\n\n\n\n::: {#exr-}\nConsider the following DataFrame.\n\n::: {.cell execution_count=87}\n``` {.python .cell-code}\ndata = [['Evert van Dijk', 'Carmine-pink, salmon-pink streaks, stripes, flecks.  Warm pink, clear carmine pink, rose pink shaded salmon.  Mild fragrance.  Large, very double, in small clusters, high-centered bloom form.  Blooms in flushes throughout the season.'],\n        ['Every Good Gift', 'Red.  Flowers velvety red.  Moderate fragrance.  Average diameter 4\".  Medium-large, full (26-40 petals), borne mostly solitary bloom form.  Blooms in flushes throughout the season.'], \n        ['Evghenya', 'Orange-pink.  75 petals.  Large, very double bloom form.  Blooms in flushes throughout the season.'], \n        ['Evita', 'White or white blend.  None to mild fragrance.  35 petals.  Large, full (26-40 petals), high-centered bloom form.  Blooms in flushes throughout the season.'],\n        ['Evrathin', 'Light pink. [Deep pink.]  Outer petals white. Expand rarely.  Mild fragrance.  35 to 40 petals.  Average diameter 2.5\".  Medium, double (17-25 petals), full (26-40 petals), cluster-flowered, in small clusters bloom form.  Prolific, once-blooming spring or summer.  Glandular sepals, leafy sepals, long sepals buds.'],\n        ['Evita 2', 'White, blush shading.  Mild, wild rose fragrance.  20 to 25 petals.  Average diameter 1.25\".  Small, very double, cluster-flowered bloom form.  Blooms in flushes throughout the season.']]\n  \ndf = pd.DataFrame(data, columns = ['NAME', 'BLOOM']) \ndf \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\Xinli\\AppData\\Roaming\\Python\\Python310\\site-packages\\IPython\\core\\formatters.py:343: FutureWarning: In future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n  return method()\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=85}\n```{=tex}\n\\begin{tabular}{lll}\n\\toprule\n{} &             NAME &                                              BLOOM \\\\\n\\midrule\n0 &   Evert van Dijk &  Carmine-pink, salmon-pink streaks, stripes, fl... \\\\\n1 &  Every Good Gift &  Red.  Flowers velvety red.  Moderate fragrance... \\\\\n2 &         Evghenya &  Orange-pink.  75 petals.  Large, very double b... \\\\\n3 &            Evita &  White or white blend.  None to mild fragrance.... \\\\\n4 &         Evrathin &  Light pink. [Deep pink.]  Outer petals white. ... \\\\\n5 &          Evita 2 &  White, blush shading.  Mild, wild rose fragran... \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nPlease use regex methods to find all the `()` in each columns.\n\n:::\n\n\n\n\n::: {#exr-}\nGet the last two rows of `df` whose row sum is greater than 100.\n\n::: {.cell execution_count=88}\n``` {.python .cell-code}\nimport pandas as pd\ndf = pd.DataFrame(np.random.randint(10, 40, 60).reshape(-1, 4))\n```\n:::\n\n\n:::\n\n\n\n::: {#exr-}\nThe groupby object `df_grouped` is given below.\n\n::: {.cell execution_count=89}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'fruit': ['apple', 'banana', 'orange'] * 3,\n                   'price': np.random.rand(9),\n                   'taste': np.random.randint(0, 11, 9)})\n\ndf_grouped = df.groupby(['fruit'])\n```\n:::\n\n\n1. Get the group belonging to `apple` as a DataFrame.\n2. Find the second largest value of `taste` for `banana`.\n3. Compute the mean `price` for every `fruit`.\n:::\n\n\n::: {#exr-}\n\nJoin `df1` and `df2` by `fruit`/`pazham` and `weight`/`kilo`.\n\n::: {.cell execution_count=90}\n``` {.python .cell-code}\ndf1 = pd.DataFrame({'fruit': ['apple', 'banana', 'orange'] * 3,\n                    'weight': ['high', 'medium', 'low'] * 3,\n                    'price': np.random.randint(0, 15, 9)})\n\ndf2 = pd.DataFrame({'pazham': ['apple', 'orange', 'pine'] * 2,\n                    'kilo': ['high', 'low'] * 3,\n                    'price': np.random.randint(0, 15, 6)})\n```\n:::\n\n\n:::\n\n## Projects\n\n\n\n::: {#exr-}\nExtract the valid emails from the series `emails`. The regex `pattern` for valid emails is provided as reference.\n\n::: {.cell execution_count=91}\n``` {.python .cell-code}\nimport pandas as pd\nemails = pd.Series(['buying books at amazom.com',\n                    'rameses@egypt.com',\n                    'matt@t.co',\n                    'narendra@modi.com'])\npattern = '[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}'\n```\n:::\n\n\n:::\n\n\n\n::: {#exr-}\nConsider the following DataFrame.\n\n::: {.cell execution_count=92}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\ndf = pd.read_csv('https://raw.githubusercontent.com/selva86/datasets/master/Cars93_miss.csv', usecols=[0,1,2,3,5])\n```\n:::\n\n\n1. Replace `NaN` with string `missing` in columns `Manufacturer`, `Model` and `Type`.\n2. Create an index as a combination of these three columns.\n\n:::\n\n\n::: {#exr-}\nGiven the following DataFrame.\n\n::: {.cell execution_count=93}\n``` {.python .cell-code}\nimport pandas as pd\ndf = pd.DataFrame({\n    'name': ['James', 'Jane', 'Melissa', 'Ed', 'Neil'],\n    'age': [30, 40, 32, 67, 43],\n    'score': ['90%', '95%', '100%', '82%', '87%'],\n    'age_missing_data': [30, 40, 32, 67, None],\n    'income':[100000, 80000, 55000, 62000, 120000]\n})\n```\n:::\n\n\n- Please use `.map` to create a new column `numeric_score` whose value is the number version of `score`. \n- Please use `.apply` to create a new column `numeric_score` whose value is the number version of `score`. \n:::\n\n\n::: {#exr-}\nFrom `ser = pd.Series(['Apple', 'Orange', 'Plan', 'Python', 'Money'])`, find the words that contain at least 2 vowels.\n:::\n\n\n\n::: {#exr-}\nPlease download the [given file](assests/datasets/test_emails.txt) with sample emails, and use the following code to load the file and save it to a string `content`.\n\n::: {.cell execution_count=94}\n``` {.python .cell-code}\nwith open('assests/datasets/test_emails.txt', 'r') as f:\n    content = f.read()\n```\n:::\n\n\nPlease use regex to play with `content`.\n\n1. Get all valid email address in `content`, from both the header part or the body part.\n2. There are two emails in `content`. Please get the sender's email and the receiver's email from `content`.\n3. Please get the sender's name.\n4. Please get the subject of each email.\n:::\n\n\n\n::: {#exr-}\nThe following DataFrame is given.\n\n::: {.cell execution_count=95}\n``` {.python .cell-code}\nimport pandas as pd\ndf = pd.DataFrame([\"STD, City    State\",\n                   \"33, Kolkata    West Bengal\",\n                   \"44, Chennai    Tamil Nadu\",\n                   \"40, Hyderabad    Telengana\",\n                   \"80, Bangalore    Karnataka\"],\n                   columns=['row'])\n```\n:::\n\n\n1. Split the columns into a list with 3 entries.\n2. Make the first row (row 0) into a header.\n3. Create a new DataFrame out of the data.\n:::\n\n",
    "supporting": [
      "04-_files\\figure-pdf"
    ],
    "filters": []
  }
}