{
  "hash": "2e60f611ff63458e2413fa96e3f9d3d7",
  "result": {
    "markdown": "# Package: `numpy`\n\nThe main reference for this chapter is @McK2017.\n\n\n## Basics\n\nThe core data structure for `numpy` is `numpy.ndarray`. It is called *NumPy N-d array*. In most cases we will use its alias `array` for simplicity. You may treat it as a generalized version of `list`. However it can do so much more than the built-in `list`. \n\nTo use `numpy`, we just import it. In most cases you would like to use the alias `np`.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n```\n:::\n\n\nUsing alias, we will just call NumPy N-d array `np.array`.\n\n### Understanding `np.array`\nThe simplest way to look at an `np.array` is to think it as lists of list. Here are some examples.\n\n- This is an example of a 1d array. Note that it can be treated as a list. You may get access to its entries by 1 index, e.g. `a[0]`. This means that: we have a list, and we want to get the `0`th element in the list.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\na = np.array([1, 2])\na\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\narray([1, 2])\n```\n:::\n:::\n\n\n- This is an example of a 2d array. Note that it can be treated as a list of lists. You may get access to its entries by 2 indexes, e.g. `b[0, 0]`. This means that: we have a list of lists. We first get the `0`th element (which is a list), and then get the `0`th element from this `0`th list (which is a number).\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nb = np.array([[1, 2], [3,4]])\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([[1, 2],\n       [3, 4]])\n```\n:::\n:::\n\n\n- This is an example of a 3d array. Note that it can be treated as a list of lists of lists. You may get access to its entries by 3 indexes, e.g. `c[0, 0, 0]`. This means that: we have a list of lists of lists. We first get the `0`th element (which is a list of lists), and then get the `0`th element (which is a list) from this `0`th list of lists, and then get the `0`th element (which is a number) from the previous list.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nc = np.array([[[1, 2], [3,4]], [[1, 2], [3,4]]])\nc\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([[[1, 2],\n        [3, 4]],\n\n       [[1, 2],\n        [3, 4]]])\n```\n:::\n:::\n\n\n#### The dimension of `np.array`\nThere is a very confusing terminology for `np.array`: dimension. The actual word using in documents is actually `axes`. It refers to the number of coordinates required to describe the location. \n\nIn the previous example, `a` is a 1d array since you only need 1 index to get entries, `b` is a 2d array since you need 2 indexes to get entries, and `c` is a 3d array since you need 3 indexes to get entries.\n\nWe could use `.ndim` to check the dimension of a `np.array`.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nd = np.array([[1, 2, 3], [4, 5, 6]])\nd.ndim\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n2\n```\n:::\n:::\n\n\n::: {.callout-note}\n## Comparing to Linear algebras\nThe dimension of an `np.array` and the dimenion of a vector in Linear algebras are totally different. In this example, as a `np.array`, `a` is a 1d `np.array`, of length `3`. As a vector, it is a 3d vector.\n:::\n\nTo describe the length of each axes, we could use `.shape`. It will tells us the length of each axis. In other words, it tells us the maximal index of each axis.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nd = np.array([[1, 2, 3], [4, 5, 6]])\nd.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n(2, 3)\n```\n:::\n:::\n\n\nThe shape of `d` is `(2, 3)`, which means that the length of axis 0 is `2` and the length of axis 1 is `3`. \n\n- Axis 0 is the vertical axis, and its index is corresponding to rows. The length of axis 0 is actually the number of rows.\n- Axis 1 is the horizental axis, and its index is corresponding to columns. The length of axis 1 is actually the number of columns.\n\nSo a 2d array can be treated as a matrix, and the shape being `(2, 3)` means that the matrix has `2` rows and `3` columns.\n:::\n\n::: {.callout-caution}\n`.ndim` and `.shape` are not methods. There is no `()` behind.\n:::\n\n\n#### Moving along axis\nA lot of `numpy` methods has an argument `axis=`, which let you to specify performing the action along which axis. You may understand this \"along axis\" in the following way. `axis=i` means that when we perform the action, we keep all other indexes the same, only changing the index on axis `i`.\n\nFor example, `b.sum(axis=0)` means that we want to add all entries along axis `0`. So we start from a certain entry, keeping all other index the same when changing index on axis `0` only, and add all these entries together. Since axis `0` is corresponding to rows index, only changing row index means we are moving vertically. So if `b` is a 2d array, `b.sum(axis=0)` means we are adding all column together.\n\nWe will do more examples later this section.\n\n\n\n### Create `np.array`\n`np.array` is called Numpy Ndarray. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called *axes*. It refers to the number of axes need to index it., and it is NOT the dimension of the vector spaces.\n\n\n\nThere are many ways to do that. \n\n- convert a list into a numpy array.\n- `np.zeros`, `np.zeros_like`\n- `np.ones`, `np.ones_like`\n- `np.eye`\n- `np.random.rand`\n- `np.arange`\n- `np.linspace`\n\n::: {.callout-note}\nPlease be very careful about the format of the input. For example, when you want to specify the dimension of the array, using `np.zeros`, you need to input a `tuple`. On the other hand, when using `np.random.rand`, you just directly input the dimensions one by one.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport numpy as np\n\nnp.zeros((3, 2))\nnp.random.rand(3, 2)\n```\n:::\n\n\nIn this case, the official documents are always your friend.\n:::\n\n\n\n### Mathematical and Statistical Methods\n\n- `+`, `-`, `*`, `/`, `**`, etc.. \n- `np.sin`, `np.exp`, `np.sqrt`, etc..\n\n- `mean`, `sum`, `std`, `var`, `cumsum`\n- `max` and `min`\n- `maximum` and `minimum`\n- `argmin` and `argmax`\n\n- `np.sort`\n- `np.unique`, `np.any`\n\n- `np.dot`: Matrix multiplication\n- `np.concatenate`\n\n- Broadcast\n\n\n::: {#exm-}\n## Axis\nGiven `A = np.array([[1,2],[3,4]])` and `B = np.array([[5,6],[7,8]])`, please use `np.concatenate` to concatencate these two matrices to get a new matrix, in the order:\n\n- `A` left, `B` right\n- `A` right, `B` left\n- `A` up, `B` down\n- `A` down, `B` up\n:::\n\n\n### Common attributes and methods\n\n- `shape`\n- `dtype`\n- `ndim`\n- Any arithmetic operations between equal-size arrays applies the operation element-wise. \n\n\n\n::: {#exm-}\n`MNIST` is a very famous dataset of hand written images. Here is how to load it. Note that in this instance of the dataset the data are stored as `numpy` arraies.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport tensorflow as tf\n\n(X_train, y_train), (X_test, y_test) = tf.keras.datasets.mnist.load_data()\nX_train.shape\n```\n:::\n\n\n:::\n\n\n\n## Indexing\n\n### Basic indexing and slicing\n\nFirst see the following example.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport numpy as np\narr = np.arange(10)\n\nprint(arr[5])\nprint(arr[5:8])\n\narr[5:8] = 12\nprint(arr)\n\nprint(arr[5:8:2])\nprint(arr[8:5:-1])\nprint(arr[::-1])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n[5 6 7]\n[ 0  1  2  3  4 12 12 12  8  9]\n[12 12]\n[ 8 12 12]\n[ 9  8 12 12 12  4  3  2  1  0]\n```\n:::\n:::\n\n\n:::\n\n\nTo do slicing in higher dimensional case, you may either treat a `numpy` array as a nested list, or you may directly work with it with multiindexes.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\narr3d = np.arange(12).reshape(2, 2, 3)\n\nprint('case 1:\\n {}'.format(arr3d))\nprint('case 2:\\n {}'.format(arr3d[0, 1, 2]))\nprint('case 3:\\n {}'.format(arr3d[:, 0: 2, 1]))\nprint('case 4:\\n {}'.format(arr3d[:, 0: 2, 1:2]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncase 1:\n [[[ 0  1  2]\n  [ 3  4  5]]\n\n [[ 6  7  8]\n  [ 9 10 11]]]\ncase 2:\n 5\ncase 3:\n [[ 1  4]\n [ 7 10]]\ncase 4:\n [[[ 1]\n  [ 4]]\n\n [[ 7]\n  [10]]]\n```\n:::\n:::\n\n\n:::\n\n\n### Boolean Indexing\n`numpy` array can accept index in terms of numpy arries with boolean indexing.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nimport numpy as np\na = np.arange(4)\nb = np.array([True, True, False, True])\nprint(a)\nprint(b)\nprint(a[b])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3]\n[ True  True False  True]\n[0 1 3]\n```\n:::\n:::\n\n\n:::\n\nWe could combine this way with the logic computation to filter out the elements we don't want.\n\n\n::: {#exm-}\nPlease replace the odd number in the array by its negative.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nimport numpy as np\narr = np.arange(10)\nodd = arr %2 == 1\narr[odd] = arr[odd] * (-1)\n\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 0 -1  2 -3  4 -5  6 -7  8 -9]\n```\n:::\n:::\n\n\n:::\n\n### Fancy indexing\nFancy indexing is a term adopted by NumPy to describe indexing using integer arrays. \n\n::: {#exm-}\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nimport numpy as np\n\narr = np.zeros((8, 4))\nfor i in range(8):\n    arr[i] = i\n\narr[[4, 3, 0, 6]]\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([[4., 4., 4., 4.],\n       [3., 3., 3., 3.],\n       [0., 0., 0., 0.],\n       [6., 6., 6., 6.]])\n```\n:::\n:::\n\n\n:::\n\n::: {#exm-}\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nimport numpy as np\n\narr = np.arange(32).reshape((8, 4))\nprint(arr)\nprint(arr[[1, 5, 7, 2], [0, 3, 1, 2]])\nprint(arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]\n [12 13 14 15]\n [16 17 18 19]\n [20 21 22 23]\n [24 25 26 27]\n [28 29 30 31]]\n[ 4 23 29 10]\n[[ 4  7  5  6]\n [20 23 21 22]\n [28 31 29 30]\n [ 8 11  9 10]]\n```\n:::\n:::\n\n\n:::\n\n\n### [Copies and views](https://numpy.org/doc/stable/user/basics.copies.html)\nThe view of an numpy array is a way to get access to the array without copying internel data. When operating with a view, the original data as well as all other views of the original data will be modified simutanously. \n\nThe default setting for copies and views is that, basic indexing and slicing will make views, and advanced indexing and slicing (e.g. boolean indexing, fancy indexing, etc.) will make copies. For other operations, you need to check the documents to know how they work. For example, `np.reshape` creates a view where possible, and `np.flatten` always creates a copy.\n\nYou may use `np.view()` or `np.copy()` to make views or copies explicitly. \n::: {#exm-}\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nimport numpy as np\narr = np.arange(10)\nb = arr[5:8]\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n\nb[0] = -1\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n\n\narr[6] = -2\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n\nprint('The base of b is {}'.format(b.base))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narr is [0 1 2 3 4 5 6 7 8 9]\nb is [5 6 7]\narr is [ 0  1  2  3  4 -1  6  7  8  9]\nb is [-1  6  7]\narr is [ 0  1  2  3  4 -1 -2  7  8  9]\nb is [-1 -2  7]\nThe base of b is [ 0  1  2  3  4 -1 -2  7  8  9]\n```\n:::\n:::\n\n\n:::\n\n\nThe way to make explicit copy is `.copy()`.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nimport numpy as np\narr = np.arange(10)\nb = arr[5:8].copy()\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n\nb[0] = -1\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n\n\narr[6] = -2\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n\nprint('The base of b is {}'.format(b.base))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narr is [0 1 2 3 4 5 6 7 8 9]\nb is [5 6 7]\narr is [0 1 2 3 4 5 6 7 8 9]\nb is [-1  6  7]\narr is [ 0  1  2  3  4  5 -2  7  8  9]\nb is [-1  6  7]\nThe base of b is None\n```\n:::\n:::\n\n\n:::\n\n\n## More commands\n\n- `.T`\n- `axis=n` is very important.\n- `np.reshape()`\n- `np.tile()`\n- `np.repeat()`\n\n\n### More advanced commands\n\n- `np.where()`\n- `np.any()`\n- `np.all()`\n- `np.argsort()`\n\n\n\n\n::: {#exm-}\nGet the position where elements of `a` and `b` match.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\na = np.array([1,2,3,2,3,4,3,4,5,6])\nb = np.array([7,2,10,2,7,4,9,4,9,8])\n\nnp.where(a == b)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n(array([1, 3, 5, 7], dtype=int64),)\n```\n:::\n:::\n\n\n:::\n\n::: {#exm-}\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\na = np.array([1,2,3,2,3,4,3,4,5,6])\nb = np.array([7,2,10,2,7,4,9,4,9,8])\n\nnp.where(a == b, a*2, b+1)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\narray([ 8,  4, 11,  4,  8,  8, 10,  8, 10,  9])\n```\n:::\n:::\n\n\n:::\n\n\n::: {#exm-}\n## Playing with axis\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nimport numpy as np\na = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])\n\nnp.any(a==1, axis=0)\nnp.any(a==1, axis=1)\nnp.any(a==1, axis=2)\n\n\nnp.any(a==2, axis=0)\nnp.any(a==2, axis=1)\nnp.any(a==2, axis=2)\n\nnp.any(a==5, axis=0)\nnp.any(a==5, axis=1)\nnp.any(a==5, axis=2)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([[False, False],\n       [ True, False]])\n```\n:::\n:::\n\n\n:::\n\n\n## Examples\n::: {#exm-}\n## Random walks\nAdam walks randomly along the axis. He starts from `0`. Every step he has equal possibility to go left or right. Please simulate this process.\n\nUse `choices` to record the choice of Adam at each step. We may generate a random array where `0` represents left and `1` represents right.\n\nUse `positions` to record the position of Adam at each step. Using `choices`, the position is `+1` if we see a `1` and the position is `-1` if we see a `0`. So the most elegent way to perform this is to \n\n1. Convert `choices` from `{0, 1}` to `{-1, 1}`.\n2. To record the starting position, we attach `0` to the beginning of the new `choices`.\n3. Apply `cumsum` to `choices` to get `positions`.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nimport numpy as np\n\nstep = 30\nchoices = np.random.randint(2, size=step)\nchoices = choices * 2 - 1\nchoices = np.concatenate(([0], choices))\npositions = choices.cumsum()\n\nimport matplotlib.pyplot as plt\nplt.plot(positions)\n```\n\n::: {.cell-output .cell-output-display}\n![](intro_files/figure-html/cell-21-output-1.png){}\n:::\n:::\n\n\n:::\n\n::: {#exm-}\n## Many random walks\nWe mainly use `numpy.ndarray` to write the code in the previous example. The best part here is that it can be easily generalized to many random walks.\n\nStill keep `choices` and `positions` in mind. Now we would like to deal with multiple people simutanously. Each row represents one person's random walk. All the formulas stay the same. We only need to update the dimension setting in the previous code.\n\n- Update `size` in `np.random.randint`.\n- Update `[0]` to `np.zeros((N, 1))` in `concatenate`.\n- For `cumsum` and `concatenate`, add `axis=1` to indicate that we perform the operations along `axis 1`.\n- We plot each row in the same figure. `plt.legend` is used to show the label for each line.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nimport numpy as np\n\nstep = 30\nN = 3\nchoices = np.random.randint(2, size=(N, step))\nchoices = choices * 2 - 1\nchoices = np.concatenate((np.zeros((N, 1)), choices), axis=1)\npositions = choices.cumsum(axis=1)\n\nimport matplotlib.pyplot as plt\nfor row in positions:\n    plt.plot(row)\nplt.legend([1, 2, 3])\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n<matplotlib.legend.Legend at 0x264c534a2f0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](intro_files/figure-html/cell-22-output-2.png){}\n:::\n:::\n\n\n:::\n\n\n::: {#exm-}\n## Analyze `positions`\nWe play with the numpy array `positions` to get some information about the random walks of three generated in the previous example.\n\n- The maximal position:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\npositions.max()\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n4.0\n```\n:::\n:::\n\n\n- The maximal position for each one:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\npositions.max(axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\narray([0., 1., 4.])\n```\n:::\n:::\n\n\n- The maximal position across all three for each step:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\npositions.max(axis=0)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\narray([ 0.,  1.,  0., -1., -2., -1.,  0., -1.,  0., -1.,  0.,  1.,  0.,\n        1.,  0.,  1.,  0.,  1.,  0.,  1.,  2.,  3.,  4.,  3.,  2.,  1.,\n        2.,  1.,  0.,  1.,  2.])\n```\n:::\n:::\n\n\n- Check whether anyone once got to the position 3:\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\n(positions>=3).any(axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\narray([False, False,  True])\n```\n:::\n:::\n\n\n- The number of people who once got to the position 3: \n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\n(positions>=3).any(axis=1).sum()\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n1\n```\n:::\n:::\n\n\n- Which step for each one gets to the right most position: \n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\npositions.argmax(axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\narray([ 0,  1, 22], dtype=int64)\n```\n:::\n:::\n\n\n:::\n\n\n## Exercises\n\nMany exercises are from @Pra2018.\n\n::: {#exr-}\n\n1. Create a $3\\times3$ matrix with values ranging from 2 to 10.\n2. Create a $10\\times10$ 2D-array with `1` on the border and `0` inside.\n3. Create a 2D array of shape `5x3` to contain random decimal numbers between `5` and `10`.\n4. Create a 1D zero `np.array` of size 10 and update sixth value to 11.\n:::\n\n\n::: {#exr-}\nWrite a function to reverse a `np.ndarray` (first element becomes last).\n:::\n\n\n\n::: {#exr-}\nGiven `a = np.array([1,2,3])`, please get the desired output `array([1, 1, 1, 2, 2, 2, 3, 3, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3])`. You may use `np.repeat()` and `np.tile()`.\n:::\n\n\n::: {#exr-}\n## Compare two `numpy` arraies\nConsider two `np.array` of the same length `x` and `y`. Compare them entry by entry. We would like to know how many are the same.\n\nPlease wrap your code into a function that return the nnumber of same entries between `x` and `y`.\n:::\n\n\n\n\n\n::: {#exr-}\n## Manipulate matries\nPlease finish the following tasks. Let `arr = np.arange(9).reshape(3,3)`.\n\n1. Swap rows `1` and `2` in the array `arr`.\n2. Reverse the rows of a 2D array `arr`.\n3. Reverse the columns of a 2D array `arr`.\n:::\n\n\n\n::: {#exr-}\nConsider a 2d `np.array`.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\narr = np.random.rand(4, 4)\n```\n:::\n\n\n1. Please compute the mean of each column.\n2. Please compute the sum of each row.\n3. Please compute the maximam of the whole array.\n:::\n\n\n::: {#exr-}\n## Adding one axis\nPlease download [this file](assests/img/20220824224849.png).   \n\n1. Please use `matplotlib.pyplot.imread()` to read the file as a 3d `np.array`. You may need to use `matplotlib` package. It will be introduced later this course. You may go to its [homepage](https://matplotlib.org/stable/users/getting_started/) to install it.\n2. Check the shape of the array.\n3. Add one additional axis to it as axis 0 to make it into a 4D array. \n:::\n\n\n::: {#exr-}\n## Understanding colored pictures\nPlease download [this file](assests/img/20220824224849.png) and use `matplotlib.pyplot.imread()` to read the file as a 3d `np.array`. You may need to use `matplotlib` package. It will be introduced later this course. You may go to its [homepage](https://matplotlib.org/stable/users/getting_started/) to install it.\n\nA colored picture is stored as a 3d `np.array`. Axis `0` and Axis `1` is about the vertical and horizontal coordinates and can help us to locate a sepecific point in the picture. Axis `2` is an array with `3` elements. It is the color vector which represents the three principal colors: red, green and blue.\n\n1. Find the maximum and minimum of the values in the array.\n2. Compute the mean of the three colors at each point to get a 2d `np.array` where each entry represents the mean of the three colors at each point of the picture.\n:::\n\n\n\n\n\n::: {#exr-}\n## Queries\n\n1. Get all items between `5` and `10` from an array `a = np.array([2, 6, 1, 9, 10, 3, 27])`.\n2. Consider `x = np.array([1, 2, 1, 1, 3, 4, 3, 1, 1, 2, 1, 1, 2])`. Please find the index of 5th repetition of number `1` in `x`.\n:::\n\n\n::: {#exr-}\nUse the following code to get the dataset `iris` and three related `np.array`: `iris_1d`, `iris_2d` and `sepallength`. \n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nimport numpy as np\n\nurl = 'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'\niris_1d = np.genfromtxt(url, delimiter=',', dtype=None, encoding=None)\niris_2d = np.genfromtxt(url, delimiter=',', dtype='float', encoding=None)\niris_2d[np.random.randint(150, size=20), np.random.randint(4, size=20)] = np.nan\nsepallength = np.genfromtxt(url, delimiter=',', dtype='float', usecols=[0],\n                            encoding=None)\n```\n:::\n\n\n1. `iris_1d` is a 1D numpy array that each item is a tuple. Please construct a new 1D numpy array that each item is the last componenet of each tuple in `iris_1d`.\n\n2. Convert `iris_1d` into a 2D array `iris_2d` by omitting the last field of each item.\n3. `np.isnan()` is a function to check whether each entry of a `np.array` is `nan` or not. Please use `np.isnan()` as well as `np.where` to find all `nan` entries in `iris_2d`. \n4. Select the rows of `iris_2d` that does not have any `nan` value.\n5. Replace all `nan` with `0` in `iris_2d`.\n:::\n\n\n\n\n\n\n::: {#exr-}\n## Random\nPlease finish the following tasks. \n\n1. Use the package `np.random` to flip a coin 100 times and record the result in a list `coin`.\n2. Assume that the coin is not fair, and the probability to get `H` is `p`. Write a code to flip the coin 100 times and record the result in a list `coin`, with a given parameter `p`. You may use `p=.4` as the first choice.\n3. For each list `coin` created above, write a code to find the longest `H` streak. We only need the biggest number of consecutive `H` we get during this 100 tosses. It is NOT necessary to know when we start the streak.\n:::\n\n<!-- \n<details>\n<summary>Click for Hint.</summary>\n\n::: {.solution}\nThe following ideas can be used to solve the problem.\n\n- `np.where`\n- string, `split` and `join`\n:::\n\n</details>\n -->\n\n\n::: {#exr-}\n## Bins\nPlease read the [document of `np.digitize`](https://numpy.org/doc/stable/reference/generated/numpy.digitize.html#numpy-digitize), and use it to do the following task.\n\nSet the following bins:\n\n- Less than `3`: `small`\n- `3-5`: `medium`\n- Bigger than `5`: `large`\n\nPlease transform the following data `iris_2c` into texts using the given bins.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nimport numpy as np\nurl = 'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'\niris_2c = np.genfromtxt(url, delimiter=',', dtype='object')[:, 2].astype('float')\n```\n:::\n\n\n:::\n\n\n\n::: {#exr-}\nConsider a 2D numpy array `a`. \n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nimport numpy as np\na = np.random.rand(5, 5)\n```\n:::\n\n\n1. Please sort it along the 3rd column.\n2. Please sort it along the 2nd row.\n\nYou may use `np.argsort()` for the problem.\n:::\n\n\n\n::: {#exr-}\n## One-hot vector\nCompute the one-hot encodings of a given array. You may use the following array as a test example. In this example, there are `3` labels. So the one-hot vectors are 3 dimensional vectors.\n\nFor more infomation about one-hot encodings, you may check the [Wiki page](https://en.wikipedia.org/wiki/One-hot#Machine_learning_and_statistics). You are not allowed to use packages that can directly compute the one-hot encodings for this problem. \n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nimport numpy as np\narr = np.random.randint(1,4, size=6)\n```\n:::\n\n\n:::\n\n\n\n::: {#exr-}\nConsider `arr = np.arange(8)`. A stride of `arr` with a window length of `4` and strides of `2` is a 2d `np.array` that looks like `[[0,1,2,3], [2,3,4,5], [4,5,6,7]]`.\n\nPlease write a function that takes `arr` and `length` and `strides` as inputs, and its stride as outputs.\n:::\n\n\n\n\n\n## References {.unnumbered}\n\n::: {#refs}\n:::\n\n",
    "supporting": [
      "intro_files"
    ],
    "filters": [],
    "includes": {}
  }
}