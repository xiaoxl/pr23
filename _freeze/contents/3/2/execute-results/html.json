{
  "hash": "d3495e290fd7ec5a59aacc1cd09361cf",
  "result": {
    "markdown": "## Indexing\n\n### Basic indexing\n\nBasic indexing is very similar to indexing and slicing for `list`. Please see the following examples.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\narr = np.arange(10)\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\narr[5]\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n5\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\narr[5:8]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([5, 6, 7])\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\narr[5:8:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([5, 7])\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\narr[8:5:-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray([8, 7, 6])\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\narr[::-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\narr[5:8] = 12\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])\n```\n:::\n:::\n\n\n:::\n\n\nTo do slicing in higher dimensional case, you may directly work with it with multiindexes.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport numpy as np\narr3d = np.arange(12).reshape(2, 2, 3)\narr3d\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([[[ 0,  1,  2],\n        [ 3,  4,  5]],\n\n       [[ 6,  7,  8],\n        [ 9, 10, 11]]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\narr3d[0, 1, 2]\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n5\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\narr3d[:, 0: 2, 1]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\narray([[ 1,  4],\n       [ 7, 10]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\narr3d[:, 0: 2, 1:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([[[ 1],\n        [ 4]],\n\n       [[ 7],\n        [10]]])\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-caution}\n# Nested indexes\nIn theory, since `ndarrys` can be treated as lists of list, it is possible to use nested index to get access to entries. For example, assuming `a` is a 2d `ndarray`, we might use `a[0][0]` to get access to `a[0, 0]`. This is a legal syntax.\n\nHowever it is almost required NOT to do so. The main reason is due to the copy/view rules that will be described later. Nested indexes might cause many confusions and it is highly possible to casue unexpected errors.\n:::\n\n### Advanced Indexing\nAdvanced indexing is triggered when the selection object satisfies some conditions. The concrete definition is technical and abstract. You may (not entirely correctly) understand it as \"everything other than basic indexing (concrete coordinates or slicing)\". Please read the [official document](https://numpy.org/doc/stable/user/basics.indexing.html#advanced-indexing) for more details. \n\nHere we mainly focus on some typical advaced indexing methods. \n\n::: {.callout-caution}\nThere are some very exotic examples that are very hard to tell whether they belong to basic indexing or advanced indexing. Our suggestion is to avoid this type of code, and try to code in the most straight forward way. You could come back to understand this problem later when you are more expericened, but it is more of a Programming Language problem, instead of a Data Science problem.\n:::\n\n\n\n\n::: {.callout-note collapse=\"true\"}\n# Fancy indexing\nFancy indexing is a term adopted by `numpy` to describe indexing using integer arrays. \n\nThe basic idea is to use a `list` of indexes to select entries. The general rule is relative complicated. Here we will only talk about 1d and 2d cases.\n\n\n::: {.callout-tip}\n# 1d case\n:::\n\nWhen dealing with a 1d `ndarray`, indexing by a `list` is straight forward. Please see the following example.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nimport numpy as np\narr = np.arange(16)\n\narr[[1, 3, 0, 2]]\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\narray([1, 3, 0, 2])\n```\n:::\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n# A trick example\nPlease consider the following two indexings. \n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\narr[1:2]\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray([1])\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\narr[[1]]\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\narray([1])\n```\n:::\n:::\n\n\nFrom the first glance, the two outputs look the same. However they are from two different techniques. \n\n- The `1:2` in `arr[1:2]` is a `slice`. Therefore the first indexing is basic indexing. \n- The `[1]` in `arr[[1]]` is a `list`. Therefore the second indexing is advanced indexing.\n\nThe main reason to distinguish these two indexings is about view and copy, which will be discussed in the next section.\n:::\n\n\n::: {.callout-tip}\n# 2d case\n:::\n\nWhen dealing with a 2d `ndarray`, there are multiple possibilities. In the following discussion we will use the following example.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nA = np.arange(16).reshape((4, 4))\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n# 1. If only one `list` is given\nIf only one `list` is given, this `list` is considered as the list of row indexes. The resulted `ndarray` is always 2d.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nA[[3, 1]]\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\narray([[12, 13, 14, 15],\n       [ 4,  5,  6,  7]])\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n# 2. If two arguments are given, one is a `list`, the other is `:`\nIf two arguments are given, one is a `list`, the other is `:`, this `list` refers to row indexes if it is in the first argument place, and refers to column indexes if it is in the second argument place. The resulted `ndarray` is always 2d.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nA[[3, 1], :]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([[12, 13, 14, 15],\n       [ 4,  5,  6,  7]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nA[:, [3, 1]]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\narray([[ 3,  1],\n       [ 7,  5],\n       [11,  9],\n       [15, 13]])\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n# 3. If both two arguments are `lists` of the same length\nIf both two arguments are `lists` of the same length, it is considered as the `list` of `axis 0` coordinates and the `list` of `axis 1` coordinates. In this case, the resulted `ndarray` is 1d.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nA[[0, 1], [3, 1]]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\narray([3, 5])\n```\n:::\n:::\n\n\nIn this example, the two `lists` together gives two entries. \n\n- The coordinate of the first entry is `(0, 3)` since they are the first entry of each `list`. The `(0, 3)` entry in `A` is `3`.\n- The coordinate of the second entry is `(1, 1)` since they are the second entry of each `list`. The `(1, 1)` entry in `A` is `5`. \n\nThen the result is `array([3, 5])`, as shown above.\n\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n# 4. If both two arguments are `lists`, and one of the `lists` is of length `1`\nIf both two arguments are `lists`, and one of the `lists` is of length `1`, it is the same as the previous case, with the `list` of length `1` being broadcasted.\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nA[[0], [3, 1]]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\narray([3, 1])\n```\n:::\n:::\n\n\nIn this example, after broadcasting, the result is the same as `A[[0,0], [3,1]]`.\n\n\n:::\n\nFor higher dimensions, please read the documents to understand how it actually works. \n\nNote that `ndarray` can also be used as indexes and it behaves very similar to `list`.\n\n:::\n\n\n\n::: {.callout-note collapse=\"true\"}\n# Boolean Indexing\n`ndarray` can accept index in terms of `ndarrays` with boolean indexing.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nimport numpy as np\na = np.arange(4)\nb = np.array([True, True, False, True])\na\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\narray([0, 1, 2, 3])\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\narray([ True,  True, False,  True])\n```\n:::\n:::\n\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\na[b]\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\narray([0, 1, 3])\n```\n:::\n:::\n\n\n:::\n\nWe could combine this way with the logic computation to filter out the elements we want/don't want.\n\n::: {#exm-}\nPlease find the odd numbers in `arr`. \n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\narr = np.arange(10)\nodd = (arr %2 == 1)\narr[odd] \n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\narray([1, 3, 5, 7, 9])\n```\n:::\n:::\n\n\n:::\n:::\n\n\n\n\n\n### [Copies and views](https://numpy.org/doc/stable/user/basics.copies.html)\nThe view of an `ndarray` is a way to get access to the array without copying internel data. When operating with a view, the original data as well as all other views of the original data will be modified simutanously. \n\n::: {#exm-}\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nimport numpy as np\narr = np.arange(10)\nb = arr[5:8]\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narr is [0 1 2 3 4 5 6 7 8 9]\nb is [5 6 7]\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nb[0] = -1\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narr is [ 0  1  2  3  4 -1  6  7  8  9]\nb is [-1  6  7]\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\narr[6] = -2\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narr is [ 0  1  2  3  4 -1 -2  7  8  9]\nb is [-1 -2  7]\n```\n:::\n:::\n\n\n:::\n\n\n\nThe default setting for copies and views is that, basic indexing will always make views, and advanced indexing (e.g. boolean indexing, fancy indexing, etc.) will make copies. For other operations, you need to check the documents to know how they work. For example, `np.reshape()` creates a view where possible, and `np.flatten()` always creates a copy.\n\nThe way to check whether something is a view or not is the attribute `.base`. If it is a view of another `ndarray`, you may see that `ndarray` in the attribute `.base`. If it is not a view, in other words, if it is a copy, the `.base` attribute is `None`.\n\n\n::: {#exm-}\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nA = np.random.rand(3, 3)\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\narray([[0.78909228, 0.64816326, 0.58962453],\n       [0.14143809, 0.71455476, 0.75184628],\n       [0.49533143, 0.26721208, 0.26321752]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nA[1:2].base\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\narray([[0.78909228, 0.64816326, 0.58962453],\n       [0.14143809, 0.71455476, 0.75184628],\n       [0.49533143, 0.26721208, 0.26321752]])\n```\n:::\n:::\n\n\nBasic indexing creates views. In this example, the `base` of `A[1:2]` is `A`, which means that `A[1:2]` is a view of `A`.\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nprint(A[[1]].base)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNone\n```\n:::\n:::\n\n\nAdvanced indexing creates copys. In this example, the `base` is `None`. So `A[[1]]` is NOT a view of anything.\n:::\n\n\n\n\nYou may use `np.view()` or `np.copy()` to make views or copies explicitly. \n\n::: {#exm-}\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\narr = np.arange(10)\nb = arr[5:8].copy()\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narr is [0 1 2 3 4 5 6 7 8 9]\nb is [5 6 7]\n```\n:::\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nb[0] = -1\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narr is [0 1 2 3 4 5 6 7 8 9]\nb is [-1  6  7]\n```\n:::\n:::\n\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\narr[6] = -2\nprint('arr is {}'.format(arr))\nprint('b is {}'.format(b))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narr is [ 0  1  2  3  4  5 -2  7  8  9]\nb is [-1  6  7]\n```\n:::\n:::\n\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nprint('The base of b is {}'.format(b.base))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe base of b is None\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "2_files"
    ],
    "filters": [],
    "includes": {}
  }
}