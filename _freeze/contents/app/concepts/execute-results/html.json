{
  "hash": "81b82478d6971f3d30ec4e0177dde8e7",
  "result": {
    "markdown": "# Some Hard Python concepts\n\n## Language\n\nPython is a programming language. \n\n## Interpreters\n\nPython needs to be interpreted into codes that computers can understand. Therefore there should be some programs that translate Python scripts. These programs are called *interpreters*.\n\n`CPython` is the refernce interpreter of Python programming language, and it is the most widely used ones for Python. It is written in C and Python. When Python programming language introduces new features, they are developed based on `CPython`, and are first implemented in `CPython`. Sometimes an interpreter is also called an *implementation*.\n\nThere are alternatives to `CPython`, like [`PyPy`](https://www.pypy.org/), [`Jython`](https://www.jython.org/), [`IronPython`](https://ironpython.net/), etc.. In theory, any Python scripts should be able to run on any of these implementations, and the result should be the same. The differences mainly come from perfamance and compatiblity with non-Python pacages. For example, `CPython` is executed by a C interpreter. Therefore it is very easy to write C-extensions for your Python code. `Jython`, since it is implemented in Java, makes it very easy to work with other Java programs that you can import any Java classes with no additional effort.\n\nSince `CPython` is most-widely used and tested, it is the best choice, at least for beginners. And actually, if you have no idea about this topic, but you use Python, it is highly possible that you are using `CPython`.\n\n\n::: {.callout-note collapse=\"true\"}\nWe mentioned \"interpreter\" here. There are mainly two types of implimentations of programming langauges: interpreters and compilers. There are also some additional types like just-in-time compilers which can be treated as combinations of the two. \n\nPython is usually treated as an *interpreted* language since `CPython` is an interpreter. One of Python's most useful features is its interactive interpreter, which allows for very fast testing of ideas without the overhead of creating test files as is typical in most programming languages.\n:::\n\n\n## REPL \nThere are two ways to use Python interpreter. The default way is that Python interpreter reads a file and execute a script from there. The second way is called *the intereactive shell*, that Python interpreter read the input from user directly, and print the result immediately. The model is like code example: prompt the user for some code, and when theyâ€™ve entered it, execute it in the same process. This model is often called a [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop), or *Read-Eval-Print-Loop*.\n\n\n\n*Shell*, *terminal*, *console* have different meanings in their original contexts. However, nowadays, especially when talking about Python intereactive shell, these terminologies are used interchangeably. They are referred to the frontend of the system. In other words, the main task for the Python intereactive shell is to handle the user inputs and communicate with the backend, which is also called a *kernel*. We won't distinguish the real differences between these terminologies. The kernel will be discussed in the next section.\n\n\nThe standard interactive Python interpreter can be invoked on the command line with the `python` command. Note that you should make sure that the `PATH` system enviroment variable is configured, otherwise you have to specifiy the path to the Python execuatable file. To quit the intereactive shell you can type the commands `quit()`/`exit()`/`Ctrl+Z` then `Enter`.\n\n\n::: {.callout-note}\nIn the REPL model, the backend (evaluation) is basically handled by the Python interpreter. The frontend is dealing with the user interface. Some typically tasks include the *primary/secondary prompt* and multi-line commands. The original REPL is very limited.\n:::\n\n## `IPython`\n`IPython` was initially designed as an Enhanced interactive Python shell. However after many year's development, the whole `IPython` project becomes too big to maintain as one single project. Therefore it is now split into many smaller projects. The two most popular projects are `IPython` and `Jupyter`. This is called [the Big Split](https://blog.jupyter.org/the-big-split-9d7b88a031a7).\n\nThe current [`IPython`](https://ipython.readthedocs.io/en/stable/overview.html) play two fundamental roles:\n\n- Terminal `IPython` as the familiar REPL;\n- The `IPython` kernel (which is defined below) that provides computation and communication with the frontend interfaces, like the notebook.\n\nThe core idea in the design of `IPython` is to abstract and extend the notion of a traditional REPL environment by decoupling the evaluation into its own process. We call this process a *kernel*: it receives execution instructions from clients and communicates the results back to them.\n\nThis decoupling allows us to have several clients connected to the same kernel, and even allows clients and kernels to live on different machines. This two-process model is now used by most of the `Jupyter` project.\n\nYou can launch the `IPython` shell on the command line with the `ipython` command (which similar to `python` case requires `PATH` configuration), and quit the shell with `exit`/`exit()`/`quit`/`quit()` commands.\n\nThe reference Python kernel provided by `IPython` is called `ipykernel`. With `ipykernel` you may create and maintain multiple kernels. \n\n\n## `Jupyter`\n[`Jupyter`](https://docs.jupyter.org/en/latest/projects/architecture/content-architecture.html) projects contain many subprojects, which includes `Jupyter` User Interfaces. The `Jupyter` user interfaces offer a foundation of interactive computing environments where scientific computing, data science, and analytics can be performed using a wide range of programming languages. This includes `Jupyter console`, `Jupyter qtconsole`, and `Jupyter notebook`. Here we mainly focus on `Jupyter notebook`.\n\n\n`Jupyter notebooks` are structured data that represent your code, metadata, content, and outputs. When saved to disk, the notebook uses the extension `.ipynb`, and uses a `JSON` structure. After receiving the user input, the notebook communicates with the kernel using `JSON` messages sent over `ZeroMQ` sockets. The protocol used between the frontends and the kernel is described in [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messaging).\n\nA kernel process can be connected to more than one frontend simultaneously. In this case, the different frontends will have access to the same variables.\n\nThis design was intended to allow easy development of different frontends based on the same kernel, but it also made it possible to support new languages in the same frontends, by developing kernels in those languages. The `Jupyter` Notebook Application has three main kernels: the `ipykernel`, `irkernel` and `ijulia` kernels. Actually the name of `Jupyter` comes from these three programming languages for data science: `Julia`, `Python` and `R`.\n\n\n\n\n## Multi-kernels setup\nThis section is mainly following the [official document](https://ipython.readthedocs.io/en/stable/install/kernel_install.html).\n\nTo install one `IPython` kernel, you may use `conda` or `pip` to install `ipykernel` in the environment. If you want to have multiple `IPython` kernels for different virtualenvs or `conda` environments, you will need to specify unique names for the kernelspecs.\n\n1. Activate the environment you want.\n\n```bash\nconda activate myenv\n```\n\n2. Install the kernel in the environment.\n\n```bash\nconda install jupyter\npython -m ipykernel install --user --name myenv --display-name \"Python (myenv)\"\n```\nThe `--name` value (in this case it is `myenv`) is used by Jupyter internally. These commands will overwrite any existing kernel with the same name. `--display-name` is what you see in the notebook menus.\n\n\n3. You could use the command to find all kernels installed in your system.\n\n\n```\njupyter kernelspeck list\n```\nAvailable kernels are shown, as well as the path to the kernel configuration file `kernel.json`. The most important configuration is the path to the Python interpreter executatable file.\n\n\n\n```{json kernel.json}\n{\n \"argv\": [\n  \"C:\\\\Users\\\\Xinli\\\\anaconda3\\\\envs\\\\base23\\\\python.exe\",\n  \"-m\",\n  \"ipykernel_launcher\",\n  \"-f\",\n  \"{connection_file}\"\n ],\n \"display_name\": \"Python (3.10)\",\n \"language\": \"python\",\n \"metadata\": {\n  \"debugger\": true\n }\n}\n```\n\n\n\n<!-- \n\nPython kernel is just a fancy name for a Python backend that was designed specifically for interactivity. The Python interpreter lies behind it. You can think of Jupyter and IPython (the actual name of the Python kernel it uses) as a middleman between you and the intepreter.\n\nAlso, PyCharm is also not an interpreter. It's an IDE. A tool that helps you write code that also acts as a middleman between you and the actual interpreter.\n\n\n\n\nKernels are programming language specific processes that run independently and interact with the Jupyter Applications and their user interfaces.\n\n\n[](https://jupyter.readthedocs.io/en/latest/projects/kernels.html)\n\n\n\n\n\n::: {.callout-note}\nShell, terminal and console are different concepts. They come from different origins. However nowadays, especially when talking about IPython and Jupyter, they are referring to the same type of things: the frontend of the system which handles the input and the output, and communicate with the kernel. We won't distinguish the real differences between them and use them interchangeably. \n:::  -->\n\n",
    "supporting": [
      "concepts_files"
    ],
    "filters": [],
    "includes": {}
  }
}