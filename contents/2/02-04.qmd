
## `list` 

`list` is a basic Python data structure. It is an ordered sequence of object types, and it is denoted by `[]`. A typical list example is `[0, 1, 2]`, which is a 3-element list.

Main questions in `list` contain creating, indexing and applications.

### Creating lists
A `list` can be created simply by writing down all the elements in order and enclosed by `[]`

::: {#exm-}

```{python}
L = [0, 1, 2]
L
```

:::

An empty list can be denoted by `[]`. 


### Indexing
There are two ways to get access to elements in a list: by position or by slice. 


::: {.callout-note collapse="true"}
## By position

Let `L` be a list. Then `L[i]` will return the `i`-th element in the list. 

- All index in Python starts from `0`. Therefore the first element is `L[0]`, the second is `L[1]`, etc..
- Negative position means go backwards. So `L[-1]` means the last element, `L[-2]` means the second last element, etc..
:::


::: {.callout-note collapse="true"}
## By slicing
`slice` is a Python object. It looks like `slice(start, stop, step)`. It represents an arithematic sequence, which starts from `start`, ends before `stop` with a step size `step`. The default step size is `1`. For example, `slice(0, 5, 1)` represents an arithematic sequence `0`, `1`, `2`, `3`, `4`. Note that `slice(0, 5, 1)` itself is a slice object, and it is NOT the list `[0, 1, 2, 3, 4]`. 

Let `L` be a list, and `s=slice(start, stop, step)` be a slice. `L[s]` is the portion of the original list `L` given by the index indicated by the slice `s`, as a list. A common way to write slice is through `:`. When slicing a list, you may also use 

```{python}
#| eval: false
L[start:stop:step]
```

1. The slice endes before `stop`. Therefore the right end point `stop` is not in the slice.
2. If `step` is not specified, `step=1` is the default value.
3. If `start` or `stop` is not specified, the default value is the first of the list or the last.
4. `start` and `stop` follows the rules of negative positions. 
5. When slicing, the result is always a list, even if it only contains one element.

::: {#exm-}

```{python}
L = ['a', 'b', 'c', 'd', 'e']
L[1:5:2]
```

```{python}
L[1:3]
```


```{python}
L[:-1]
```

```{python}
L[-1:0:-1]
```

:::

:::



- Access to the data
- Slicing

### Methods
- Methods
    - `append` 
    - `extend` and `+`
    <!-- - `pop` -->
    <!-- - `remove` -->
- `in`



::: {.callout-caution collapse=true}
## The importance of documents

::: {#exm-}
## Sorting a list
Let `a=[3, 1, 2]` be a list. We would like to sort the list. There are two different built-in methods. 

```{python}
a = [3, 1, 2]
b = sorted(a)
b
```
The first method is straightforward and we get what we expected. However if we use the same idea, and write the codes in the following way, we will get something unexpected. 

```{python}
a = [3, 1, 2]
b = a.sort()
print(b)
```
`b` won't be directly printed since `b` is actually `None`. The way that `.sort()` works is that it sort the list inplace. In other words, the method doesn't have an output. It directly change the original list.

```{python}
a
```
:::


This is an example to show that similar functions may behaves differently. It is actually very hard to predict what would happen since it all depends on how the developer of the function thinks about the problems.

Therefore it is very important to know how to find references. Other than simply asking questions on StackOverflow or other forums, the official documents are always your good friend. For example, you may find the answer to the above problems from [`sorted`](https://docs.python.org/3/library/functions.html#sorted) and [`.sort()`](https://docs.python.org/3/library/stdtypes.html#list.sort).


:::



### Work with `for` loop

- `for`


### Work with `str`

- `list()`
- `sorted`

- `str.split`
- `str.join`




### List Comprehension
List Comprehension is a convenient way to create lists based on the values of an existing list. It cannot provide any real improvement to the performance of the codes, but it can make the codes shorter and easier to read.

The format of list Comprehension is
```{python}
#| eval: false
newlist = [expression for item in iterable if condition == True]
```
   

