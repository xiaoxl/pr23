## Indexing

### Basic indexing and slicing

Basic indexing and slicing is very similar to indexing and slicing for `list`. Please see the following examples.


::: {#exm-}
```{python}
import numpy as np
arr = np.arange(10)
arr
```


```{python}
arr[5]
```

```{python}
arr[5:8]
```

```{python}
arr[5:8:2]
```

```{python}
arr[8:5:-1]
```

```{python}
arr[::-1]
```

```{python}
arr[5:8] = 12
arr
```

:::


To do slicing in higher dimensional case, you may directly work with it with multiindexes.


::: {#exm-}

```{python}
import numpy as np
arr3d = np.arange(12).reshape(2, 2, 3)
arr3d
```

```{python}
arr3d[0, 1, 2]
```

```{python}
arr3d[:, 0: 2, 1]
```

```{python}
arr3d[:, 0: 2, 1:2]
```

:::


::: {.callout-caution}
# Nested indexes
In theory, since `ndarrys` can be treated as lists of list, it is possible to use nested index to get access to entries. For example, assuming `a` is a 2d `ndarray`, we might use `a[0][0]` to get access to `a[0, 0]`. This is a legal syntax.

However it is almost required NOT to do so. The main reason is due to the copy/view rules that will be described later. Nested index might cause many confusions and it is highly possible to casue unexpected errors.
:::


### Boolean Indexing
`ndarray` can accept index in terms of `ndarrays` with boolean indexing.


::: {#exm-}

```{python}
import numpy as np
a = np.arange(4)
b = np.array([True, True, False, True])
a
```

```{python}
b
```

```{python}
a[b]
```

:::

We could combine this way with the logic computation to filter out the elements we don't want.


::: {#exm-}
Please replace the odd number in the array by its negative.

```{python}
import numpy as np
arr = np.arange(10)
odd = (arr %2 == 1)
arr[odd] = arr[odd] * (-1)
arr
```


:::

### Fancy indexing
Fancy indexing is a term adopted by `numpy` to describe indexing using integer arrays. 

::: {#exm-}

```{python}
import numpy as np

arr = np.zeros((8, 4))
for i in range(8):
    arr[i] = i

arr[[4, 3, 0, 6]]
```

:::

::: {#exm-}

```{python}
import numpy as np

arr = np.arange(32).reshape((8, 4))
print(arr)
print(arr[[1, 5, 7, 2], [0, 3, 1, 2]])
print(arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]])
```

:::


### [Copies and views](https://numpy.org/doc/stable/user/basics.copies.html)
The view of an numpy array is a way to get access to the array without copying internel data. When operating with a view, the original data as well as all other views of the original data will be modified simutanously. 

The default setting for copies and views is that, basic indexing and slicing will make views, and advanced indexing and slicing (e.g. boolean indexing, fancy indexing, etc.) will make copies. For other operations, you need to check the documents to know how they work. For example, `np.reshape` creates a view where possible, and `np.flatten` always creates a copy.

You may use `np.view()` or `np.copy()` to make views or copies explicitly. 
::: {#exm-}

```{python}
import numpy as np
arr = np.arange(10)
b = arr[5:8]
print('arr is {}'.format(arr))
print('b is {}'.format(b))

b[0] = -1
print('arr is {}'.format(arr))
print('b is {}'.format(b))


arr[6] = -2
print('arr is {}'.format(arr))
print('b is {}'.format(b))

print('The base of b is {}'.format(b.base))
```
:::


The way to make explicit copy is `.copy()`.


::: {#exm-}

```{python}
import numpy as np
arr = np.arange(10)
b = arr[5:8].copy()
print('arr is {}'.format(arr))
print('b is {}'.format(b))

b[0] = -1
print('arr is {}'.format(arr))
print('b is {}'.format(b))


arr[6] = -2
print('arr is {}'.format(arr))
print('b is {}'.format(b))

print('The base of b is {}'.format(b.base))
```
:::
